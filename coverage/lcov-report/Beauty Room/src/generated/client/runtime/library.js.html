
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for Beauty Room/src/generated/client/runtime/library.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">Beauty Room/src/generated/client/runtime</a> library.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">37.06% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>53/143</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">50.99% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>206/404</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">13.57% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>128/943</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">37.06% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>53/143</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";var zl=Object.create;var Lr=Object.defineProperty;var Yl=Object.getOwnPropertyDescriptor;var Zl=Object.getOwnPropertyNames;var Xl=Object.getPrototypeOf,eu=Object.prototype.hasOwnProperty;var Z=(e,t)=&gt;()=&gt;(t||e((t={exports:{}}).exports,t),t.exports),Vt=(e,t)=&gt;{for(var r in t)Lr(e,r,{get:t[r],enumerable:!0})},mo=(e,t,r,n)=&gt;{if(t&amp;&amp;typeof t=="object"||typeof t=="function")for(let i of Zl(t))!eu.call(e,i)&amp;&amp;i!==r&amp;&amp;Lr(e,i,{get:()=&gt;t[i],enumerable:!(n=Yl(t,i))||n.enumerable});return e};var k=(e,t,r)=&gt;(r=e!=null?zl(Xl(e))<span class="branch-0 cbranch-no" title="branch not covered" >:{},</span>mo(t||!e||!e.__esModule?Lr(r,"default",{value:e,enumerable:!0}):r,e)),tu=e=&gt;mo(Lr({},"__esModule",{value:!0}),e);var Mo=Z((af,Yn)=&gt;{"use strict";var v=Yn.exports;Yn.exports.default=v;var D="\x1B[",Jt="\x1B]",ft="\x07",Qr=";",No=process.env.TERM_PROGRAM==="Apple_Terminal";v.cursorTo=<span class="fstat-no" title="function not covered" >(e,t)=&gt;{if(typeof e!="number")throw new TypeError("The `x` argument is required");return typeof t!="number"?D+(e+1)+"G":D+(t+1)+";"+(e+1)+"H"};</span>v.cursorMove=<span class="fstat-no" title="function not covered" >(e,t)=&gt;{if(typeof e!="number")throw new TypeError("The `x` argument is required");let r="";return e&lt;0?r+=D+-e+"D":e&gt;0&amp;&amp;(r+=D+e+"C"),t&lt;0?r+=D+-t+"A":t&gt;0&amp;&amp;(r+=D+t+"B"),r};</span>v.cursorUp=<span class="fstat-no" title="function not covered" >(e=1)=&gt;D+e+"A";</span>v.cursorDown=<span class="fstat-no" title="function not covered" >(e=1)=&gt;D+e+"B";</span>v.cursorForward=<span class="fstat-no" title="function not covered" >(e=1)=&gt;D+e+"C";</span>v.cursorBackward=<span class="fstat-no" title="function not covered" >(e=1)=&gt;D+e+"D";</span>v.cursorLeft=D+"G";v.cursorSavePosition=No<span class="branch-0 cbranch-no" title="branch not covered" >?"\x1B7":</span>D+"s";v.cursorRestorePosition=No<span class="branch-0 cbranch-no" title="branch not covered" >?"\x1B8":</span>D+"u";v.cursorGetPosition=D+"6n";v.cursorNextLine=D+"E";v.cursorPrevLine=D+"F";v.cursorHide=D+"?25l";v.cursorShow=D+"?25h";v.eraseLines=<span class="fstat-no" title="function not covered" >e=&gt;{let t="";for(let r=0;r&lt;e;r++)t+=v.eraseLine+(r&lt;e-1?v.cursorUp():"");return e&amp;&amp;(t+=v.cursorLeft),t};</span>v.eraseEndLine=D+"K";v.eraseStartLine=D+"1K";v.eraseLine=D+"2K";v.eraseDown=D+"J";v.eraseUp=D+"1J";v.eraseScreen=D+"2J";v.scrollUp=D+"S";v.scrollDown=D+"T";v.clearScreen="\x1Bc";v.clearTerminal=process.platform==="win32"<span class="branch-0 cbranch-no" title="branch not covered" >?`${v.eraseScreen}${D}0f`:</span>`${v.eraseScreen}${D}3J${D}H`;v.beep=ft;v.link=<span class="fstat-no" title="function not covered" >(e,t)=&gt;[Jt,"8",Qr,Qr,t,ft,e,Jt,"8",Qr,Qr,ft].join("");</span>v.image=<span class="fstat-no" title="function not covered" >(e,t={})=&gt;{let r=`${Jt}1337;File=inline=1`;return t.width&amp;&amp;(r+=`;width=${t.width}`),t.height&amp;&amp;(r+=`;height=${t.height}`),t.preserveAspectRatio===!1&amp;&amp;(r+=";preserveAspectRatio=0"),r+":"+e.toString("base64")+ft};</span>v.iTerm={setCwd:<span class="fstat-no" title="function not covered" >(e=process.cwd())=&gt;`${Jt}50;CurrentDir=${e}${ft}`,</span>annotation:<span class="fstat-no" title="function not covered" >(e,t={})=&gt;{let r=`${Jt}1337;`,n=typeof t.x&lt;"u",i=typeof t.y&lt;"u";if((n||i)&amp;&amp;!(n&amp;&amp;i&amp;&amp;typeof t.length&lt;"u"))throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");return e=e.replace(/\|/g,""),r+=t.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",t.length&gt;0?r+=(n?[e,t.length,t.x,t.y]:[t.length,e]).join("|"):r+=e,r+ft}}</span>});var Zn=Z((lf,$o)=&gt;{"use strict";$o.exports=(e,t=process.argv)=&gt;{let r=e.startsWith("-")<span class="branch-0 cbranch-no" title="branch not covered" >?"":</span>e.length===1<span class="branch-0 cbranch-no" title="branch not covered" >?"-":</span>"--",n=t.indexOf(r+e),i=t.indexOf("--");return n!==-1<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(i===-1||n&lt;i)}</span>});var Vo=Z((uf,jo)=&gt;{"use strict";var ju=require("os"),qo=require("tty"),de=Zn(),{env:Q}=process,Qe;de("no-color")||de("no-colors")||de("color=false")||de("color=never")<span class="branch-0 cbranch-no" title="branch not covered" >?Qe=0:</span>(de("color")||de("colors")||de("color=true")||de("color=always")<span class="branch-0 cbranch-no" title="branch not covered" >)&amp;&amp;(Qe=1);</span>"FORCE_COLOR"in Q&amp;&amp;(Q.FORCE_COLOR==="true"<span class="branch-0 cbranch-no" title="branch not covered" >?Qe=1:</span>Q.FORCE_COLOR==="false"<span class="branch-0 cbranch-no" title="branch not covered" >?Qe=0:</span>Qe=Q.FORCE_COLOR.length===0<span class="branch-0 cbranch-no" title="branch not covered" >?1:</span>Math.min(parseInt(Q.FORCE_COLOR,10),3));function Xn(e){return e===0<span class="branch-0 cbranch-no" title="branch not covered" >?!1:</span>{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}function ei(e,t){if(Qe===0)<span class="branch-0 cbranch-no" title="branch not covered" >return 0;i</span>f(de("color=16m")||de("color=full")||de("color=truecolor"))<span class="branch-0 cbranch-no" title="branch not covered" >return 3;i</span>f(de("color=256"))<span class="branch-0 cbranch-no" title="branch not covered" >return 2;i</span>f(e&amp;&amp;!t&amp;&amp;Qe===void 0)<span class="branch-0 cbranch-no" title="branch not covered" >return 0;l</span>et r=Qe<span class="branch-0 cbranch-no" title="branch not covered" >||0;</span>if(Q.TERM==="dumb")<span class="branch-0 cbranch-no" title="branch not covered" >return r;i</span>f(process.platform==="win32")<span class="branch-0 cbranch-no" title="branch not covered" >{let n=ju.release().split(".");return Number(n[0])&gt;=10&amp;&amp;Number(n[2])&gt;=10586?Number(n[2])&gt;=14931?3:2:1}i</span>f("CI"in Q)<span class="branch-0 cbranch-no" title="branch not covered" >return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(n=&gt;n in Q)||Q.CI_NAME==="codeship"?1:r;i</span>f("TEAMCITY_VERSION"in Q)<span class="branch-0 cbranch-no" title="branch not covered" >return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Q.TEAMCITY_VERSION)?1:0;i</span>f(Q.COLORTERM==="truecolor")return 3<span class="branch-0 cbranch-no" title="branch not covered" >;if("TERM_PROGRAM"in Q){let n=parseInt((Q.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(Q.TERM_PROGRAM){case"iTerm.app":return n&gt;=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(Q.TERM)?2<span class="branch-0 cbranch-no" title="branch not covered" >:</span>/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Q.TERM)||"COLORTERM"in Q?1:r}</span>function Vu(e){let t=ei(e,e&amp;&amp;e.isTTY);return Xn(t)}jo.exports={supportsColor:Vu,stdout:Xn(ei(!0,qo.isatty(1))),stderr:Xn(ei(!0,qo.isatty(2)))}});var Go=Z((cf,Uo)=&gt;{"use strict";var Bu=Vo(),gt=Zn();<span class="fstat-no" title="function not covered" >function Bo(e){if(/^\d{3,4}$/.test(e)){let r=/(\d{1,2})(\d{2})/.exec(e);return{major:0,minor:parseInt(r[1],10),patch:parseInt(r[2],10)}}let t=(e||"").split(".").map(r=&gt;parseInt(r,10));return{major:t[0],minor:t[1],patch:t[2]}}f</span>unction ti(e){let{env:t}=process;if("FORCE_HYPERLINK"in t)<span class="branch-0 cbranch-no" title="branch not covered" >return!(t.FORCE_HYPERLINK.length&gt;0&amp;&amp;parseInt(t.FORCE_HYPERLINK,10)===0);i</span>f(gt("no-hyperlink")||gt("no-hyperlinks")||gt("hyperlink=false")||gt("hyperlink=never"))<span class="branch-0 cbranch-no" title="branch not covered" >return!1;i</span>f(gt("hyperlink=true")||gt("hyperlink=always")||"NETLIFY"in t)<span class="branch-0 cbranch-no" title="branch not covered" >return!0;i</span>f(!Bu.supportsColor(e)||e&amp;&amp;!e.isTTY<span class="branch-0 cbranch-no" title="branch not covered" >||process.platform==="win32"<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|"CI"in t<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|"TEAMCITY_VERSION"in t)</span>return!1<span class="branch-0 cbranch-no" title="branch not covered" >;if("TERM_PROGRAM"in t){let r=Bo(t.TERM_PROGRAM_VERSION);switch(t.TERM_PROGRAM){case"iTerm.app":return r.major===3?r.minor&gt;=1:r.major&gt;3;case"WezTerm":return r.major&gt;=20200620;case"vscode":return r.major&gt;1||r.major===1&amp;&amp;r.minor&gt;=72}}if("VTE_VERSION"in t){if(t.VTE_VERSION==="0.50.0")return!1;let r=Bo(t.VTE_VERSION);return r.major&gt;0||r.minor&gt;=50}return!1}U</span>o.exports={supportsHyperlink:ti,stdout:ti(process.stdout),stderr:ti(process.stderr)}});var Jo=Z((pf,Wt)=&gt;{"use strict";var Uu=Mo(),ri=Go(),Qo=<span class="fstat-no" title="function not covered" >(e,t,{target:r="stdout",...n}={})=&gt;ri[r]?Uu.link(e,t):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,t):`${e} (\u200B${t}\u200B)`;</span>Wt.exports=<span class="fstat-no" title="function not covered" >(e,t,r={})=&gt;Qo(e,t,r);</span>Wt.exports.stderr=<span class="fstat-no" title="function not covered" >(e,t,r={})=&gt;Qo(e,t,{target:"stderr",...r});</span>Wt.exports.isSupported=ri.stdout;Wt.exports.stderr.isSupported=ri.stderr});var ii=Z((xf,Gu)=&gt;{Gu.exports={name:"@prisma/engines-version",version:"5.21.1-1.bf0e5e8a04cada8225617067eaa03d041e2bba36",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"bf0e5e8a04cada8225617067eaa03d041e2bba36"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.34",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var oi=Z(Jr=&gt;{"use strict";Object.defineProperty(Jr,"__esModule",{value:!0});Jr.enginesVersion=void 0;Jr.enginesVersion=ii().prisma.enginesVersion});var zo=Z((jf,Wu)=&gt;{Wu.exports={name:"dotenv",version:"16.0.3",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{require:"./lib/main.js",types:"./lib/main.d.ts",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard","lint-readme":"standard-markdown",pretest:"npm run lint &amp;&amp; npm run dts-check",test:"tap tests/*.js --100 -Rspec",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^17.0.9",decache:"^4.6.1",dtslint:"^3.7.0",sinon:"^12.0.1",standard:"^16.0.4","standard-markdown":"^7.1.0","standard-version":"^9.3.2",tap:"^15.1.6",tar:"^6.1.11",typescript:"^4.5.4"},engines:{node:"&gt;=12"}}});var Zo=Z((Vf,Hr)=&gt;{"use strict";var Hu=require("fs"),Yo=require("path"),Ku=require("os"),zu=zo(),Yu=zu.version,Zu=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function Xu(e){let t={},r=e.toString();r=r.replace(/\r\n?/mg,`
`);let n;for(;(n=Zu.exec(r))!=null;){let i=n[1],o=n[2]<span class="branch-0 cbranch-no" title="branch not covered" >||"";</span>o=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&amp;&amp;(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),t[i]=o}return t}<span class="fstat-no" title="function not covered" >function ui(e){console.log(`[dotenv@${Yu}][DEBUG] ${e}`)}f</span>unction ec(e){return e[0]==="~"<span class="branch-0 cbranch-no" title="branch not covered" >?Yo.join(Ku.homedir(),e.slice(1)):</span>e}function tc(e){let t=Yo.resolve(process.cwd(),".env"),r="utf8",n=!!(e&amp;&amp;e.debug),i=!!(e&amp;&amp;e.override);e&amp;&amp;(e.path!=null&amp;&amp;(t=ec(e.path)),e.encoding!=null<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(r=e.encoding))</span>;try{let o=Wr.parse(Hu.readFileSync(t,{encoding:r}));return Object.keys(o).forEach(function(s){Object.prototype.hasOwnProperty.call(process.env,s)?(i===!0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(process.env[s]=o[s]),</span>n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ui(i===!0?`"${s}" is already defined in \`process.env\` and WAS overwritten`:`"${s}" is already defined in \`process.env\` and was NOT overwritten`)<span class="branch-0 cbranch-no" title="branch not covered" >)</span>:process.env[s]=o[s]}</span>),{parsed:o}}<span class="branch-0 cbranch-no" title="branch not covered" >catch(o){return n&amp;&amp;ui(`Failed to load ${t} ${o.message}`),{error:o}}}</span>var Wr={config:tc,parse:Xu};Hr.exports.config=Wr.config;Hr.exports.parse=Wr.parse;Hr.exports=Wr});var is=Z((Hf,ns)=&gt;{"use strict";ns.exports=<span class="fstat-no" title="function not covered" >e=&gt;{let t=e.match(/^[ \t]*(?=\S)/gm);return t?t.reduce((r,n)=&gt;Math.min(r,n.length),1/0):0}}</span>);var ss=Z((Kf,os)=&gt;{"use strict";var oc=is();os.exports=<span class="fstat-no" title="function not covered" >e=&gt;{let t=oc(e);if(t===0)return e;let r=new RegExp(`^[ \\t]{${t}}`,"gm");return e.replace(r,"")}}</span>);var mi=Z((tg,as)=&gt;{"use strict";as.exports=<span class="fstat-no" title="function not covered" >(e,t=1,r)=&gt;{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;let n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))}}</span>);var ps=Z((ig,cs)=&gt;{"use strict";cs.exports=<span class="fstat-no" title="function not covered" >({onlyFirst:e=!1}={})=&gt;{let t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");return new RegExp(t,e?void 0:"g")}}</span>);var yi=Z((og,ds)=&gt;{"use strict";var mc=ps();ds.exports=<span class="fstat-no" title="function not covered" >e=&gt;typeof e=="string"?e.replace(mc(),""):e}</span>);var ms=Z((lg,Yr)=&gt;{"use strict";Yr.exports=<span class="fstat-no" title="function not covered" >(e={})=&gt;{let t;if(e.repoUrl)t=e.repoUrl;else if(e.user&amp;&amp;e.repo)t=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let r=new URL(`${t}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"];for(let i of n){let o=e[i];if(o!==void 0){if(i==="labels"||i==="projects"){if(!Array.isArray(o))throw new TypeError(`The \`${i}\` option should be an array`);o=o.join(",")}r.searchParams.set(i,o)}}return r.toString()};</span>Yr.exports.default=Yr.exports});var no=Z((av,Za)=&gt;{"use strict";Za.exports=function(){<span class="fstat-no" title="function not covered" >function e(t,r,n,i,o){return t&lt;r||n&lt;r?t&gt;n?n+1:t+1:i===o?r:r+1}r</span>eturn function(t,r){if(t===r)return 0;if(t.length&gt;r.length){var n=t;t=r,r=n}for(var i=t.length,o=r.length;i&gt;0&amp;&amp;t.charCodeAt(i-1)===r.charCodeAt(o-1);)i--,o--;for(var s=0;s&lt;i&amp;&amp;t.charCodeAt(s)===r.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o&lt;3)return o;var a=0,l,u,c,p,d,f,g,h,O,T,S,C,E=[];for(l=0;l&lt;i;l++)E.push(l+1),E.push(t.charCodeAt(s+l));for(var me=E.length-1;a&lt;o-3;)for(O=r.charCodeAt(s+(u=a)),T=r.charCodeAt(s+(c=a+1)),S=r.charCodeAt(s+(p=a+2)),C=r.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l&lt;me;l+=2)g=E[l],h=E[l+1],u=e(g,u,c,O,h),c=e(u,c,p,T,h),p=e(c,p,d,S,h),f=e(p,d,f,C,h),E[l]=f,d=p,p=c,c=u,u=g;for(;a&lt;o;)for(O=r.charCodeAt(s+(u=a)),f=++a,l=0;l&lt;me;l+=2)g=E[l],E[l]=f=e(g,u,f,O,E[l+1]),u=g;return f}}()});var Dm={};Vt(Dm,{Debug:()=&gt;Un,Decimal:()=&gt;Re,Extensions:()=&gt;qn,MetricsClient:<span class="fstat-no" title="function not covered" >()=&gt;bt,</span>NotFoundError:()=&gt;Le,PrismaClientInitializationError:()=&gt;R,PrismaClientKnownRequestError:()=&gt;V,PrismaClientRustPanicError:()=&gt;le,PrismaClientUnknownRequestError:()=&gt;B,PrismaClientValidationError:()=&gt;J,Public:()=&gt;jn,Sql:<span class="fstat-no" title="function not covered" >()=&gt;ie,</span>defineDmmfProperty:()=&gt;gs,empty:()=&gt;Es,getPrismaClient:()=&gt;Wl,getRuntime:()=&gt;Tn,join:()=&gt;bs,makeStrictEnum:()=&gt;Hl,makeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()=&gt;ys,</span>objectEnumValues:()=&gt;en,raw:()=&gt;Si,skip:()=&gt;tn,sqltag:()=&gt;Ai,warnEnvConflicts:()=&gt;Kl,warnOnce:()=&gt;Xt});module.exports=tu(Dm);var qn={};Vt(qn,{defineExtension:()=&gt;fo,getExtensionContext:()=&gt;go});<span class="fstat-no" title="function not covered" >function fo(e){return typeof e=="function"?e:t=&gt;t.$extends(e)}<span class="fstat-no" title="function not covered" >f</span>unction go(e){return e}v</span>ar jn={};Vt(jn,{validator:()=&gt;ho});<span class="fstat-no" title="function not covered" >function ho(...e){return t=&gt;t}v</span>ar Nr={};Vt(Nr,{$:<span class="fstat-no" title="function not covered" >()=&gt;xo,</span>bgBlack:<span class="fstat-no" title="function not covered" >()=&gt;pu,</span>bgBlue:<span class="fstat-no" title="function not covered" >()=&gt;gu,</span>bgCyan:<span class="fstat-no" title="function not covered" >()=&gt;yu,</span>bgGreen:<span class="fstat-no" title="function not covered" >()=&gt;mu,</span>bgMagenta:<span class="fstat-no" title="function not covered" >()=&gt;hu,</span>bgRed:<span class="fstat-no" title="function not covered" >()=&gt;du,</span>bgWhite:<span class="fstat-no" title="function not covered" >()=&gt;bu,</span>bgYellow:<span class="fstat-no" title="function not covered" >()=&gt;fu,</span>black:<span class="fstat-no" title="function not covered" >()=&gt;au,</span>blue:<span class="fstat-no" title="function not covered" >()=&gt;rt,</span>bold:<span class="fstat-no" title="function not covered" >()=&gt;H,</span>cyan:<span class="fstat-no" title="function not covered" >()=&gt;De,</span>dim:<span class="fstat-no" title="function not covered" >()=&gt;Oe,</span>gray:<span class="fstat-no" title="function not covered" >()=&gt;Bt,</span>green:<span class="fstat-no" title="function not covered" >()=&gt;qe,</span>grey:<span class="fstat-no" title="function not covered" >()=&gt;cu,</span>hidden:<span class="fstat-no" title="function not covered" >()=&gt;ou,</span>inverse:<span class="fstat-no" title="function not covered" >()=&gt;iu,</span>italic:<span class="fstat-no" title="function not covered" >()=&gt;nu,</span>magenta:<span class="fstat-no" title="function not covered" >()=&gt;lu,</span>red:<span class="fstat-no" title="function not covered" >()=&gt;ce,</span>reset:<span class="fstat-no" title="function not covered" >()=&gt;ru,</span>strikethrough:<span class="fstat-no" title="function not covered" >()=&gt;su,</span>underline:<span class="fstat-no" title="function not covered" >()=&gt;X,</span>white:<span class="fstat-no" title="function not covered" >()=&gt;uu,</span>yellow:<span class="fstat-no" title="function not covered" >()=&gt;ke}</span>);var Vn,yo,bo,Eo,wo=!0;typeof process&lt;"u"&amp;&amp;({FORCE_COLOR:Vn,NODE_DISABLE_COLORS:yo,NO_COLOR:bo,TERM:Eo}=process.env<span class="branch-0 cbranch-no" title="branch not covered" >||{},</span>wo=process.stdout&amp;&amp;process.stdout.isTTY);var xo={enabled:!yo&amp;&amp;bo==null&amp;&amp;Eo!=="dumb"&amp;&amp;(Vn!=null&amp;&amp;Vn!=="0"<span class="branch-0 cbranch-no" title="branch not covered" >||wo)</span>};function M(e,t){let r=new RegExp(`\\x1b\\[${t}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${t}m`;return function(o){return!xo.enabled||o==null<span class="branch-0 cbranch-no" title="branch not covered" >?o:</span>n+(~(""+o).indexOf(i)<span class="branch-0 cbranch-no" title="branch not covered" >?o.replace(r,i+n):</span>o)+i}}var ru=M(0,0),H=M(1,22),Oe=M(2,22),nu=M(3,23),X=M(4,24),iu=M(7,27),ou=M(8,28),su=M(9,29),au=M(30,39),ce=M(31,39),qe=M(32,39),ke=M(33,39),rt=M(34,39),lu=M(35,39),De=M(36,39),uu=M(37,39),Bt=M(90,39),cu=M(90,39),pu=M(40,49),du=M(41,49),mu=M(42,49),fu=M(43,49),gu=M(44,49),hu=M(45,49),yu=M(46,49),bu=M(47,49);var Eu=100,Po=["green","yellow","blue","magenta","cyan","red"],Ut=[],vo=Date.now(),wu=0,Bn=typeof process&lt;"u"?process.env<span class="branch-0 cbranch-no" title="branch not covered" >:{};</span>globalThis.DEBUG??=Bn.DEBUG??"";globalThis.DEBUG_COLORS??=Bn.DEBUG_COLORS<span class="branch-0 cbranch-no" title="branch not covered" >?Bn.DEBUG_COLORS==="true":</span>!0;var Gt={<span class="fstat-no" title="function not covered" >enable(e){typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)},<span class="fstat-no" title="function not covered" ></span>disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},</span>enabled(e){let t=globalThis.DEBUG.split(",").map(i=&gt;i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),r=t.some(i=&gt;i===""<span class="branch-0 cbranch-no" title="branch not covered" >||i[0]==="-"?</span>!1<span class="branch-0 cbranch-no" title="branch not covered" >:e.match(RegExp(i.split("*").join(".*")+"$")))</span>,n=t.some(i=&gt;i===""<span class="branch-0 cbranch-no" title="branch not covered" >||i[0]!=="-"?</span>!1<span class="branch-0 cbranch-no" title="branch not covered" >:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")))</span>;return r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!n}</span>,log:<span class="fstat-no" title="function not covered" >(...e)=&gt;{let[t,r,...n]=e;(console.warn??console.log)(`${t} ${r}`,...n)},</span>formatters:{}};function xu(e){let t={color:Po[wu++%Po.length],enabled:Gt.enabled(e),namespace:e,log:Gt.log,extend:<span class="fstat-no" title="function not covered" >()=&gt;{}}</span>,r=(...n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=t;if(n.length!==0&amp;&amp;Ut.push([o,...n]),Ut.length&gt;Eu<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Ut.shift(),</span>Gt.enabled(o)||i)<span class="branch-0 cbranch-no" title="branch not covered" >{let l=n.map(c=&gt;typeof c=="string"?c:Pu(c)),u=`+${Date.now()-vo}ms`;vo=Date.now(),globalThis.DEBUG_COLORS?a(Nr[s](H(o)),...l,Nr[s](u)):a(o,...l,u)}}</span>;return new Proxy(r,{get:<span class="fstat-no" title="function not covered" >(n,i)=&gt;t[i],</span>set:<span class="fstat-no" title="function not covered" >(n,i,o)=&gt;t[i]=o}</span>)}var Un=new Proxy(xu,{get:<span class="fstat-no" title="function not covered" >(e,t)=&gt;Gt[t],</span>set:<span class="fstat-no" title="function not covered" >(e,t,r)=&gt;Gt[t]=r}</span>);<span class="fstat-no" title="function not covered" >function Pu(e,t=2){let r=new Set;return JSON.stringify(e,(n,i)=&gt;{if(typeof i=="object"&amp;&amp;i!==null){if(r.has(i))return"[Circular *]";r.add(i)}else if(typeof i=="bigint")return i.toString();return i},t)}<span class="fstat-no" title="function not covered" >f</span>unction To(e=7500){let t=Ut.map(([r,...n])=&gt;`${r} ${n.map(i=&gt;typeof i=="string"?i:JSON.stringify(i)).join(" ")}`).join(`</span>
`);return t.length&lt;e?t:t.slice(-e)}<span class="fstat-no" title="function not covered" >function Ro(){Ut.length=0}v</span>ar L=Un;var Co=k(require("fs"));function Gn(){let e=process.env.PRISMA_QUERY_ENGINE_LIBRARY;if(!(e<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Co.default.existsSync(e))</span>&amp;&amp;process.arch==="ia32")<span class="branch-0 cbranch-no" title="branch not covered" >throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}v</span>ar Qn=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var Mr="libquery_engine";function $r(e,t){let r=t==="url";return e.includes("windows")<span class="branch-0 cbranch-no" title="branch not covered" >?r?"query_engine.dll.node":`query_engine-${e}.dll.node`:</span>e.includes("darwin")?r<span class="branch-0 cbranch-no" title="branch not covered" >?`${Mr}.dylib.node`:</span>`${Mr}-${e}.dylib.node`<span class="branch-0 cbranch-no" title="branch not covered" >:r?`${Mr}.so.node`:`${Mr}-${e}.so.node`}</span>var Oo=k(require("child_process")),Kn=k(require("fs/promises")),Ur=k(require("os"));var _e=Symbol.for("@ts-pattern/matcher"),vu=Symbol.for("@ts-pattern/isVariadic"),jr="@ts-pattern/anonymous-select-key",Jn=<span class="fstat-no" title="function not covered" >e=&gt;!!(e&amp;&amp;typeof e=="object"),</span>qr=<span class="fstat-no" title="function not covered" >e=&gt;e&amp;&amp;!!e[_e],</span>Ee=<span class="fstat-no" title="function not covered" >(e,t,r)=&gt;{if(qr(e)){let n=e[_e](),{matched:i,selections:o}=n.match(t);return i&amp;&amp;o&amp;&amp;Object.keys(o).forEach(s=&gt;r(s,o[s])),i}if(Jn(e)){if(!Jn(t))return!1;if(Array.isArray(e)){if(!Array.isArray(t))return!1;let n=[],i=[],o=[];for(let s of e.keys()){let a=e[s];qr(a)&amp;&amp;a[vu]?o.push(a):o.length?i.push(a):n.push(a)}if(o.length){if(o.length&gt;1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(t.length&lt;n.length+i.length)return!1;let s=t.slice(0,n.length),a=i.length===0?[]:t.slice(-i.length),l=t.slice(n.length,i.length===0?1/0:-i.length);return n.every((u,c)=&gt;Ee(u,s[c],r))&amp;&amp;i.every((u,c)=&gt;Ee(u,a[c],r))&amp;&amp;(o.length===0||Ee(o[0],l,r))}return e.length===t.length&amp;&amp;e.every((s,a)=&gt;Ee(s,t[a],r))}return Object.keys(e).every(n=&gt;{let i=e[n];return(n in t||qr(o=i)&amp;&amp;o[_e]().matcherType==="optional")&amp;&amp;Ee(i,t[n],r);var o})}return Object.is(t,e)},</span>Ge=<span class="fstat-no" title="function not covered" >e=&gt;{var t,r,n;return Jn(e)?qr(e)?(t=(r=(n=e[_e]()).getSelectionKeys)==null?void 0:r.call(n))!=null?t:[]:Array.isArray(e)?Qt(e,Ge):Qt(Object.values(e),Ge):[]},</span>Qt=<span class="fstat-no" title="function not covered" >(e,t)=&gt;e.reduce((r,n)=&gt;r.concat(t(n)),[]);</span>function pe(e){return Object.assign(e,{optional:<span class="fstat-no" title="function not covered" >()=&gt;Tu(e),</span>and:<span class="fstat-no" title="function not covered" >t=&gt;j(e,t),</span>or:<span class="fstat-no" title="function not covered" >t=&gt;Ru(e,t),</span>select:<span class="fstat-no" title="function not covered" >t=&gt;t===void 0?So(e):So(t,e)}</span>)}<span class="fstat-no" title="function not covered" >function Tu(e){return pe({[_e]:()=&gt;({match:t=&gt;{let r={},n=(i,o)=&gt;{r[i]=o};return t===void 0?(Ge(e).forEach(i=&gt;n(i,void 0)),{matched:!0,selections:r}):{matched:Ee(e,t,n),selections:r}},getSelectionKeys:()=&gt;Ge(e),matcherType:"optional"})})}<span class="fstat-no" title="function not covered" >f</span>unction j(...e){return pe({[_e]:()=&gt;({match:t=&gt;{let r={},n=(i,o)=&gt;{r[i]=o};return{matched:e.every(i=&gt;Ee(i,t,n)),selections:r}},getSelectionKeys:()=&gt;Qt(e,Ge),matcherType:"and"})})}<span class="fstat-no" title="function not covered" >f</span>unction Ru(...e){return pe({[_e]:()=&gt;({match:t=&gt;{let r={},n=(i,o)=&gt;{r[i]=o};return Qt(e,Ge).forEach(i=&gt;n(i,void 0)),{matched:e.some(i=&gt;Ee(i,t,n)),selections:r}},getSelectionKeys:()=&gt;Qt(e,Ge),matcherType:"or"})})}f</span>unction I(e){return{[_e]:<span class="fstat-no" title="function not covered" >()=&gt;({match:t=&gt;({matched:!!e(t)})})}</span>}<span class="fstat-no" title="function not covered" >function So(...e){let t=typeof e[0]=="string"?e[0]:void 0,r=e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];return pe({[_e]:()=&gt;({match:n=&gt;{let i={[t??jr]:n};return{matched:r===void 0||Ee(r,n,(o,s)=&gt;{i[o]=s}),selections:i}},getSelectionKeys:()=&gt;[t??jr].concat(r===void 0?[]:Ge(r))})})}<span class="fstat-no" title="function not covered" >f</span>unction ye(e){return typeof e=="number"}<span class="fstat-no" title="function not covered" >f</span>unction je(e){return typeof e=="string"}<span class="fstat-no" title="function not covered" >f</span>unction Ve(e){return typeof e=="bigint"}v</span>ar Qm=pe(I(function(e){return!0}));var Be=e=&gt;Object.assign(pe(e),{startsWith:<span class="fstat-no" title="function not covered" >t=&gt;{return Be(j(e,(r=t,I(n=&gt;je(n)&amp;&amp;n.startsWith(r)))));var r},</span>endsWith:<span class="fstat-no" title="function not covered" >t=&gt;{return Be(j(e,(r=t,I(n=&gt;je(n)&amp;&amp;n.endsWith(r)))));var r},</span>minLength:<span class="fstat-no" title="function not covered" >t=&gt;Be(j(e,(r=&gt;I(n=&gt;je(n)&amp;&amp;n.length&gt;=r))(t))),</span>length:<span class="fstat-no" title="function not covered" >t=&gt;Be(j(e,(r=&gt;I(n=&gt;je(n)&amp;&amp;n.length===r))(t))),</span>maxLength:<span class="fstat-no" title="function not covered" >t=&gt;Be(j(e,(r=&gt;I(n=&gt;je(n)&amp;&amp;n.length&lt;=r))(t))),</span>includes:<span class="fstat-no" title="function not covered" >t=&gt;{return Be(j(e,(r=t,I(n=&gt;je(n)&amp;&amp;n.includes(r)))));var r},</span>regex:<span class="fstat-no" title="function not covered" >t=&gt;{return Be(j(e,(r=t,I(n=&gt;je(n)&amp;&amp;!!n.match(r)))));var r}}</span>),Jm=Be(I(je)),be=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(t,r)=&gt;be(j(e,((n,i)=&gt;I(o=&gt;ye(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(t,r))),</span>lt:<span class="fstat-no" title="function not covered" >t=&gt;be(j(e,(r=&gt;I(n=&gt;ye(n)&amp;&amp;n&lt;r))(t))),</span>gt:<span class="fstat-no" title="function not covered" >t=&gt;be(j(e,(r=&gt;I(n=&gt;ye(n)&amp;&amp;n&gt;r))(t))),</span>lte:<span class="fstat-no" title="function not covered" >t=&gt;be(j(e,(r=&gt;I(n=&gt;ye(n)&amp;&amp;n&lt;=r))(t))),</span>gte:<span class="fstat-no" title="function not covered" >t=&gt;be(j(e,(r=&gt;I(n=&gt;ye(n)&amp;&amp;n&gt;=r))(t))),</span>int:<span class="fstat-no" title="function not covered" >()=&gt;be(j(e,I(t=&gt;ye(t)&amp;&amp;Number.isInteger(t)))),</span>finite:<span class="fstat-no" title="function not covered" >()=&gt;be(j(e,I(t=&gt;ye(t)&amp;&amp;Number.isFinite(t)))),</span>positive:<span class="fstat-no" title="function not covered" >()=&gt;be(j(e,I(t=&gt;ye(t)&amp;&amp;t&gt;0))),</span>negative:<span class="fstat-no" title="function not covered" >()=&gt;be(j(e,I(t=&gt;ye(t)&amp;&amp;t&lt;0)))}</span>),Wm=be(I(ye)),Ue=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(t,r)=&gt;Ue(j(e,((n,i)=&gt;I(o=&gt;Ve(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(t,r))),</span>lt:<span class="fstat-no" title="function not covered" >t=&gt;Ue(j(e,(r=&gt;I(n=&gt;Ve(n)&amp;&amp;n&lt;r))(t))),</span>gt:<span class="fstat-no" title="function not covered" >t=&gt;Ue(j(e,(r=&gt;I(n=&gt;Ve(n)&amp;&amp;n&gt;r))(t))),</span>lte:<span class="fstat-no" title="function not covered" >t=&gt;Ue(j(e,(r=&gt;I(n=&gt;Ve(n)&amp;&amp;n&lt;=r))(t))),</span>gte:<span class="fstat-no" title="function not covered" >t=&gt;Ue(j(e,(r=&gt;I(n=&gt;Ve(n)&amp;&amp;n&gt;=r))(t))),</span>positive:<span class="fstat-no" title="function not covered" >()=&gt;Ue(j(e,I(t=&gt;Ve(t)&amp;&amp;t&gt;0))),</span>negative:<span class="fstat-no" title="function not covered" >()=&gt;Ue(j(e,I(t=&gt;Ve(t)&amp;&amp;t&lt;0)))}</span>),Hm=Ue(I(Ve)),Km=pe(I(function(e){return typeof e=="boolean"})),zm=pe(I(function(e){return typeof e=="symbol"})),Ym=pe(I(function(e){return e==null})),Zm=pe(I(function(e){return e!=null}));var Wn={matched:!1,value:void 0};<span class="fstat-no" title="function not covered" >function mt(e){return new Hn(e,Wn)}v</span>ar Hn=class e{<span class="fstat-no" title="function not covered" >constructor(t,r){this.input=void 0,this.state=void 0,this.input=t,this.state=r}<span class="fstat-no" title="function not covered" >w</span>ith(...t){if(this.state.matched)return this;let r=t[t.length-1],n=[t[0]],i;t.length===3&amp;&amp;typeof t[1]=="function"?i=t[1]:t.length&gt;2&amp;&amp;n.push(...t.slice(1,t.length-1));let o=!1,s={},a=(u,c)=&gt;{o=!0,s[u]=c},l=!n.some(u=&gt;Ee(u,this.input,a))||i&amp;&amp;!i(this.input)?Wn:{matched:!0,value:r(o?jr in s?s[jr]:s:this.input,this.input)};return new e(this.input,l)}<span class="fstat-no" title="function not covered" >w</span>hen(t,r){if(this.state.matched)return this;let n=!!t(this.input);return new e(this.input,n?{matched:!0,value:r(this.input,this.input)}:Wn)}<span class="fstat-no" title="function not covered" >o</span>therwise(t){return this.state.matched?this.state.value:t(this.input)}<span class="fstat-no" title="function not covered" >e</span>xhaustive(){if(this.state.matched)return this.state.value;let t;try{t=JSON.stringify(this.input)}catch{t=this.input}throw new Error(`Pattern matching error: no pattern matches value ${t}`)}<span class="fstat-no" title="function not covered" >r</span>un(){return this.exhaustive()}<span class="fstat-no" title="function not covered" >r</span>eturnType(){return this}}</span>;var ko=require("util");var Cu={warn:ke("prisma:warn")},Su={warn:<span class="fstat-no" title="function not covered" >()=&gt;!process.env.PRISMA_DISABLE_WARNINGS}</span>;<span class="fstat-no" title="function not covered" >function Vr(e,...t){Su.warn()&amp;&amp;console.warn(`${Cu.warn} ${e}`,...t)}v</span>ar Au=(0,ko.promisify)(Oo.default.exec),te=L("prisma:get-platform"),Iu=["1.0.x","1.1.x","3.0.x"];async function Do(){let e=Ur.default.platform(),t=process.arch;if(e==="freebsd")<span class="branch-0 cbranch-no" title="branch not covered" >{let s=await Gr("freebsd-version");if(s&amp;&amp;s.trim().length&gt;0){let l=/^(\d+)\.?/.exec(s);if(l)return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:t}}}i</span>f(e!=="linux")return{platform:e,arch:t}<span class="branch-0 cbranch-no" title="branch not covered" >;let r=await ku(),n=await qu(),i=_u({arch:t,archFromUname:n,familyDistro:r.familyDistro}),{libssl:o}=await Fu(i);return{platform:"linux",libssl:o,arch:t,archFromUname:n,...r}}<span class="fstat-no" title="function not covered" >f</span>unction Ou(e){let t=/^ID="?([^"\n]*)"?$/im,r=/^ID_LIKE="?([^"\n]*)"?$/im,n=t.exec(e),i=n&amp;&amp;n[1]&amp;&amp;n[1].toLowerCase()||"",o=r.exec(e),s=o&amp;&amp;o[1]&amp;&amp;o[1].toLowerCase()||"",a=mt({id:i,idLike:s}).with({id:"alpine"},({id:l})=&gt;({targetDistro:"musl",familyDistro:l,originalDistro:l})).with({id:"raspbian"},({id:l})=&gt;({targetDistro:"arm",familyDistro:"debian",originalDistro:l})).with({id:"nixos"},({id:l})=&gt;({targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).with({id:"debian"},{id:"ubuntu"},({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).with({id:"rhel"},{id:"centos"},{id:"fedora"},({id:l})=&gt;({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).when(({idLike:l})=&gt;l.includes("debian")||l.includes("ubuntu"),({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).when(({idLike:l})=&gt;i==="arch"||l.includes("arch"),({id:l})=&gt;({targetDistro:"debian",familyDistro:"arch",originalDistro:l})).when(({idLike:l})=&gt;l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),({id:l})=&gt;({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).otherwise(({id:l})=&gt;({targetDistro:void 0,familyDistro:void 0,originalDistro:l}));return te(`Found distro info:</span>
${JSON.stringify(a,null,2)}`),a}<span class="fstat-no" title="function not covered" >async function ku(){let e="/etc/os-release";try{let t=await Kn.default.readFile(e,{encoding:"utf-8"});return Ou(t)}catch{return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}}<span class="fstat-no" title="function not covered" >f</span>unction Du(e){let t=/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);if(t){let r=`${t[1]}.x`;return _o(r)}}<span class="fstat-no" title="function not covered" >f</span>unction Ao(e){let t=/libssl\.so\.(\d)(\.\d)?/.exec(e);if(t){let r=`${t[1]}${t[2]??".0"}.x`;return _o(r)}}<span class="fstat-no" title="function not covered" >f</span>unction _o(e){let t=(()=&gt;{if(Lo(e))return e;let r=e.split(".");return r[1]="0",r.join(".")})();if(Iu.includes(t))return t}<span class="fstat-no" title="function not covered" >f</span>unction _u(e){return mt(e).with({familyDistro:"musl"},()=&gt;(te('Trying platform-specific paths for "alpine"'),["/lib"])).with({familyDistro:"debian"},({archFromUname:t})=&gt;(te('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${t}-linux-gnu`,`/lib/${t}-linux-gnu`])).with({familyDistro:"rhel"},()=&gt;(te('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).otherwise(({familyDistro:t,arch:r,archFromUname:n})=&gt;(te(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`),[]))}<span class="fstat-no" title="function not covered" >a</span>sync function Fu(e){let t='grep -v "libssl.so.0"',r=await Io(e);if(r){te(`Found libssl.so file using platform-specific paths: ${r}`);let o=Ao(r);if(te(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"libssl-specific-path"}}te('Falling back to "ldconfig" and other generic paths');let n=await Gr(`ldconfig -p | sed "s/.*=&gt;s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);if(n||(n=await Io(["/lib64","/usr/lib64","/lib"])),n){te(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);let o=Ao(n);if(te(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"ldconfig"}}let i=await Gr("openssl version -v");if(i){te(`Found openssl binary with version: ${i}`);let o=Du(i);if(te(`The parsed openssl version is: ${o}`),o)return{libssl:o,strategy:"openssl-binary"}}return te("Couldn't find any version of libssl or OpenSSL in the system"),{}}<span class="fstat-no" title="function not covered" >a</span>sync function Io(e){for(let t of e){let r=await Lu(t);if(r)return r}}<span class="fstat-no" title="function not covered" >a</span>sync function Lu(e){try{return(await Kn.default.readdir(e)).find(r=&gt;r.startsWith("libssl.so.")&amp;&amp;!r.startsWith("libssl.so.0"))}catch(t){if(t.code==="ENOENT")return;throw t}}a</span>sync function nt(){let{binaryTarget:e}=await Fo();return e}function Nu(e){return e.binaryTarget!==void 0}async function zn(){let{memoized:e,...t}=await Fo();return t}var Br={};async function Fo(){if(Nu(Br))return Promise.resolve({...Br,memoized:!0});let e=await Do(),t=Mu(e);return Br={...e,binaryTarget:t},{...Br,memoized:!1}}function Mu(e){let{platform:t,arch:r,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;t==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!["x64","arm64"].includes(r)<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;Vr(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);</span>let l="1.1.x";if(t==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let c=mt({familyDistro:s}).with({familyDistro:"debian"},()=&gt;"Please manually install OpenSSL via `apt-get update -y &amp;&amp; apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(()=&gt;"Please manually install OpenSSL and try installing Prisma again.");Vr(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".</span>
${c}`)}let u="debian";if(t==="linux"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;o===void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;te(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),</span>t==="darwin"&amp;&amp;r==="arm64")return"darwin-arm64"<span class="branch-0 cbranch-no" title="branch not covered" >;if(t==="darwin")return"darwin";if(t==="win32")return"windows";if(t==="freebsd")return o;if(t==="openbsd")return"openbsd";if(t==="netbsd")return"netbsd";if(t==="linux"&amp;&amp;o==="nixos")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return"linux-nixos";if(t==="linux"&amp;&amp;r==="arm64")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;if(t==="linux"&amp;&amp;r==="arm")<span class="branch-0 cbranch-no" title="branch not covered" ></span>return`linux-arm-openssl-${i||l}`;if(t==="linux"&amp;&amp;o==="musl")<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let c="linux-musl";return!i||Lo(i)?c:`${c}-openssl-${i}`}return t==="linux"&amp;&amp;o<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;i<span class="branch-0 cbranch-no" title="branch not covered" >?</span>`${o}-openssl-${i}`<span class="branch-0 cbranch-no" title="branch not covered" >:</span>(t!=="linux"&amp;&amp;Vr(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}<span class="fstat-no" title="function not covered" ></span>async function $u(e){try{return await e()}catch{return}}<span class="fstat-no" title="function not covered" >f</span>unction Gr(e){return $u(async()=&gt;{let t=await Au(e);return te(`Command "${e}" successfully returned "${t.stdout}"`),t.stdout})}<span class="fstat-no" title="function not covered" >a</span>sync function qu(){return typeof Ur.default.machine=="function"?Ur.default.machine():(await Gr("uname -m"))?.trim()}<span class="fstat-no" title="function not covered" >f</span>unction Lo(e){return e.startsWith("1.")}v</span>ar Wo=k(Jo());<span class="fstat-no" title="function not covered" >function ni(e){return(0,Wo.default)(e,e,{fallback:X})}v</span>ar Qu=k(oi());var $=k(require("path")),Ju=k(oi()),kf=L("prisma:engines");<span class="fstat-no" title="function not covered" >function Ho(){return $.default.join(__dirname,"../")}v</span>ar Df="libquery-engine";$.default.join(__dirname,"../query-engine-darwin");$.default.join(__dirname,"../query-engine-darwin-arm64");$.default.join(__dirname,"../query-engine-debian-openssl-1.0.x");$.default.join(__dirname,"../query-engine-debian-openssl-1.1.x");$.default.join(__dirname,"../query-engine-debian-openssl-3.0.x");$.default.join(__dirname,"../query-engine-linux-static-x64");$.default.join(__dirname,"../query-engine-linux-static-arm64");$.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x");$.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");$.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");$.default.join(__dirname,"../libquery_engine-darwin.dylib.node");$.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");$.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");$.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");$.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");$.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");$.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");$.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");$.default.join(__dirname,"../libquery_engine-linux-musl.so.node");$.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");$.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");$.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");$.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");$.default.join(__dirname,"../query_engine-windows.dll.node");var si=k(require("fs")),Ko=L("chmodPlusX");<span class="fstat-no" title="function not covered" >function ai(e){if(process.platform==="win32")return;let t=si.default.statSync(e),r=t.mode|64|8|1;if(t.mode===r){Ko(`Execution permissions of ${e} are fine`);return}let n=r.toString(8).slice(-3);Ko(`Have to call chmodPlusX on ${e}`),si.default.chmodSync(e,n)}<span class="fstat-no" title="function not covered" >f</span>unction li(e){let t=e.e,r=a=&gt;`Prisma cannot find the required \`${a}\` system library in your system`,n=t.message.includes("cannot open shared object file"),i=`Please refer to the documentation about Prisma's system requirements: ${ni("https://pris.ly/d/system-requirements")}`,o=`Unable to require(\`${Oe(e.id)}\`).`,s=mt({message:t.message,code:t.code}).with({code:"ENOENT"},()=&gt;"File does not exist.").when(({message:a})=&gt;n&amp;&amp;a.includes("libz"),()=&gt;`${r("libz")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libgcc_s"),()=&gt;`${r("libgcc_s")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libssl"),()=&gt;{let a=e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";return`${r("libssl")}. Please install ${a} and try again.`}).when(({message:a})=&gt;a.includes("GLIBC"),()=&gt;`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({message:a})=&gt;e.platformInfo.platform==="linux"&amp;&amp;a.includes("symbol not found"),()=&gt;`The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(()=&gt;`The Prisma engines do not seem to be compatible with your system. ${i}`);return`${o}</span>
<span class="cstat-no" title="statement not covered" >${s}</span>
<span class="cstat-no" title="statement not covered" ></span>
Details: ${t.message}`}var pi=k(Zo()),Kr=k(require("fs"));var ht=k(require("path"));function Xo(e){let t=e.ignoreProcessEnv<span class="branch-0 cbranch-no" title="branch not covered" >?{}:</span>process.env,r=n=&gt;n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)<span class="branch-0 cbranch-no" title="branch not covered" >?.reduce(</span>function(o,s){let a=/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);if(!a)return o;let l=a[1],u,c;if(l==="\\")c=a[0],u=c.replace("\\$","$");else{let p=a[2];c=a[0].substring(l.length),u=Object.hasOwnProperty.call(t,p)?t[p]:e.parsed[p]||"",u=r(u)}return o.replace(c,u)},n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(t,n)?t[n]<span class="branch-0 cbranch-no" title="branch not covered" >:e.parsed[n];</span>e.parsed[n]=r(i)}for(let n in e.parsed)t[n]=e.parsed[n];return e}var ci=L("prisma:tryLoadEnv");function Ht({rootEnvPath:e,schemaEnvPath:t},r={conflictCheck:"none"}){let n=es(e);r.conflictCheck!=="none"&amp;&amp;rc(n,t,r.conflictCheck);let i=null;return ts(n<span class="branch-0 cbranch-no" title="branch not covered" >?.path,</span>t)||(i=es(t)),!n&amp;&amp;!i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ci("No Environment variables loaded"),</span>i?.dotenvResult.error<span class="branch-0 cbranch-no" title="branch not covered" >?console.error(ce(H("Schema Env Error: "))+i.dotenvResult.error):</span>{message:[n<span class="branch-0 cbranch-no" title="branch not covered" >?.message,</span>i?.message].filter(Boolean).join(`
`),parsed:{...n<span class="branch-0 cbranch-no" title="branch not covered" >?.dotenvResult?.parsed,</span>...i?.dotenvResult?.parsed}}}function rc(e,t,r){let n=e<span class="branch-0 cbranch-no" title="branch not covered" >?.dotenvResult.</span>parsed,i=!ts(e<span class="branch-0 cbranch-no" title="branch not covered" >?.path,</span>t);if(n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;Kr.default.existsSync(t))<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let o=pi.default.parse(Kr.default.readFileSync(t)),s=[];for(let a in o)n[a]===o[a]&amp;&amp;s.push(a);if(s.length&gt;0){let a=ht.default.relative(process.cwd(),e.path),l=ht.default.relative(process.cwd(),t);if(r==="error"){let u=`There is a conflict between env var${s.length&gt;1?"s":""} in ${X(a)} and ${X(l)}</span>
<span class="cstat-no" title="statement not covered" >Conflicting env vars:</span>
<span class="cstat-no" title="statement not covered" >${s.map(c=&gt;`  ${H(c)}`).join(`</span>
<span class="cstat-no" title="statement not covered" >`)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >We suggest to move the contents of ${X(l)} to ${X(a)} to consolidate your env vars.</span>
<span class="cstat-no" title="statement not covered" >`;throw new Error(u)}else if(r==="warn"){let u=`Conflict for env var${s.length&gt;1?"s":""} ${s.map(c=&gt;H(c)).join(", ")} in ${X(a)} and ${X(l)}</span>
<span class="cstat-no" title="statement not covered" >Env vars from ${X(l)} overwrite the ones from ${X(a)}</span>
      `;console.warn(`${ke("warn(prisma)")} ${u}`)}}}}function es(e){if(nc(e)){ci(`Environment variables loaded from ${e}`);let t=pi.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG<span class="branch-0 cbranch-no" title="branch not covered" >?!0:</span>void 0});return{dotenvResult:Xo(t),message:Oe(`Environment variables loaded from ${ht.default.relative(process.cwd(),e)}`),path:e}}else ci(`Environment variables not found at ${e}`);return null}function ts(e,t){return e<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;ht.default.resolve(e)===ht.default.resolve(t)}</span>function nc(e){return!!(e&amp;&amp;Kr.default.existsSync(e))}var rs="library";function Kt(e){let t=ic();return t||(e?.config.engineType==="library"?"library"<span class="branch-0 cbranch-no" title="branch not covered" >:e?.config.engineType==="binary"?"binary":rs)</span>}function ic(){let e=process.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"<span class="branch-0 cbranch-no" title="branch not covered" >?"library":</span>e==="binary"<span class="branch-0 cbranch-no" title="branch not covered" >?"binary":</span>void 0}var Je;(t=&gt;{let e;(E=&gt;(E.findUnique="findUnique",E.findUniqueOrThrow="findUniqueOrThrow",E.findFirst="findFirst",E.findFirstOrThrow="findFirstOrThrow",E.findMany="findMany",E.create="create",E.createMany="createMany",E.createManyAndReturn="createManyAndReturn",E.update="update",E.updateMany="updateMany",E.upsert="upsert",E.delete="delete",E.deleteMany="deleteMany",E.groupBy="groupBy",E.count="count",E.aggregate="aggregate",E.findRaw="findRaw",E.aggregateRaw="aggregateRaw"))(e=t.ModelAction||={})})(Je||={});var zt=k(require("path"));<span class="fstat-no" title="function not covered" >function di(e){return zt.default.sep===zt.default.posix.sep?e:e.split(zt.default.sep).join(zt.default.posix.sep)}v</span>ar ls=k(mi());<span class="fstat-no" title="function not covered" >function gi(e){return String(new fi(e))}v</span>ar fi=class{<span class="fstat-no" title="function not covered" >constructor(t){this.config=t}<span class="fstat-no" title="function not covered" >t</span>oString(){let{config:t}=this,r=t.provider.fromEnvVar?`env("${t.provider.fromEnvVar}")`:t.provider.value,n=JSON.parse(JSON.stringify({provider:r,binaryTargets:sc(t.binaryTargets)}));return`generator ${t.name} {</span>
<span class="cstat-no" title="statement not covered" >${(0,ls.default)(ac(n),2)}</span>
}`}};<span class="fstat-no" title="function not covered" >function sc(e){let t;if(e.length&gt;0){let r=e.find(n=&gt;n.fromEnvVar!==null);r?t=`env("${r.fromEnvVar}")`:t=e.map(n=&gt;n.native?"native":n.value)}else t=void 0;return t}<span class="fstat-no" title="function not covered" >f</span>unction ac(e){let t=Object.keys(e).reduce((r,n)=&gt;Math.max(r,n.length),0);return Object.entries(e).map(([r,n])=&gt;`${r.padEnd(t)} = ${lc(n)}`).join(`</span>
`)}<span class="fstat-no" title="function not covered" >function lc(e){return JSON.parse(JSON.stringify(e,(t,r)=&gt;Array.isArray(r)?`[${r.map(n=&gt;JSON.stringify(n)).join(", ")}]`:JSON.stringify(r)))}v</span>ar Zt={};Vt(Zt,{error:<span class="fstat-no" title="function not covered" >()=&gt;pc,</span>info:<span class="fstat-no" title="function not covered" >()=&gt;cc,</span>log:<span class="fstat-no" title="function not covered" >()=&gt;uc,</span>query:<span class="fstat-no" title="function not covered" >()=&gt;dc,</span>should:<span class="fstat-no" title="function not covered" >()=&gt;us,</span>tags:<span class="fstat-no" title="function not covered" >()=&gt;Yt,</span>warn:<span class="fstat-no" title="function not covered" >()=&gt;hi}</span>);var Yt={error:ce("prisma:error"),warn:ke("prisma:warn"),info:De("prisma:info"),query:rt("prisma:query")},us={warn:<span class="fstat-no" title="function not covered" >()=&gt;!process.env.PRISMA_DISABLE_WARNINGS}</span>;<span class="fstat-no" title="function not covered" >function uc(...e){console.log(...e)}<span class="fstat-no" title="function not covered" >f</span>unction hi(e,...t){us.warn()&amp;&amp;console.warn(`${Yt.warn} ${e}`,...t)}<span class="fstat-no" title="function not covered" >f</span>unction cc(e,...t){console.info(`${Yt.info} ${e}`,...t)}<span class="fstat-no" title="function not covered" >f</span>unction pc(e,...t){console.error(`${Yt.error} ${e}`,...t)}<span class="fstat-no" title="function not covered" >f</span>unction dc(e,...t){console.log(`${Yt.query} ${e}`,...t)}<span class="fstat-no" title="function not covered" >f</span>unction zr(e,t){if(!e)throw new Error(`${t}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}<span class="fstat-no" title="function not covered" >f</span>unction Fe(e,t){throw new Error(t)}<span class="fstat-no" title="function not covered" >f</span>unction bi(e,t){return Object.prototype.hasOwnProperty.call(e,t)}v</span>ar Ei=<span class="fstat-no" title="function not covered" >(e,t)=&gt;e.reduce((r,n)=&gt;(r[t(n)]=n,r),{});<span class="fstat-no" title="function not covered" ></span>function yt(e,t){let r={};for(let n of Object.keys(e))r[n]=t(e[n],n);return r}<span class="fstat-no" title="function not covered" >f</span>unction wi(e,t){if(e.length===0)return;let r=e[0];for(let n=1;n&lt;e.length;n++)t(r,e[n])&lt;0&amp;&amp;(r=e[n]);return r}f</span>unction w(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}var fs=new Set,Xt=<span class="fstat-no" title="function not covered" >(e,t,...r)=&gt;{fs.has(e)||(fs.add(e),hi(t,...r))};</span>var V=class extends Error{<span class="fstat-no" title="function not covered" >constructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}}</span>;w(V,"PrismaClientKnownRequestError");var Le=class extends V{<span class="fstat-no" title="function not covered" >constructor(t,r){super(t,{code:"P2025",clientVersion:r}),this.name="NotFoundError"}}</span>;w(Le,"NotFoundError");var R=class e extends Error{<span class="fstat-no" title="function not covered" >constructor(t,r,n){super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"PrismaClientInitializationError"}}</span>;w(R,"PrismaClientInitializationError");var le=class extends Error{<span class="fstat-no" title="function not covered" >constructor(t,r){super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"PrismaClientRustPanicError"}}</span>;w(le,"PrismaClientRustPanicError");var B=class extends Error{<span class="fstat-no" title="function not covered" >constructor(t,{clientVersion:r,batchRequestIdx:n}){super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}}</span>;w(B,"PrismaClientUnknownRequestError");var J=class extends Error{<span class="fstat-no" title="function not covered" >constructor(r,{clientVersion:n}){super(r);this.name="PrismaClientValidationError";this.clientVersion=n}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"PrismaClientValidationError"}}</span>;w(J,"PrismaClientValidationError");var bt=class{constructor(t){this._engine=t}<span class="fstat-no" title="function not covered" >prometheus(t){return this._engine.metrics({format:"prometheus",...t})}<span class="fstat-no" title="function not covered" >j</span>son(t){return this._engine.metrics({format:"json",...t})}}</span>;function er(e){let t;return{<span class="fstat-no" title="function not covered" >get(){return t||(t={value:e()}),t.value}}</span>}function gs(e,t){let r=er(()=&gt;fc(t));Object.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()=&gt;r.get()}</span>)}<span class="fstat-no" title="function not covered" >function fc(e){return{datamodel:{models:xi(e.models),enums:xi(e.enums),types:xi(e.types)}}}<span class="fstat-no" title="function not covered" >f</span>unction xi(e){return Object.entries(e).map(([t,r])=&gt;({name:t,...r}))}v</span>ar Xr=Symbol(),Pi=new WeakMap,Ne=class{constructor(t){t===Xr?Pi.set(this,`Prisma.${this._getName()}`)<span class="branch-0 cbranch-no" title="branch not covered" >:Pi.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}</span>_getName(){return this.constructor.name}<span class="fstat-no" title="function not covered" >toString(){return Pi.get(this)}}</span>,tr=class extends Ne{<span class="fstat-no" title="function not covered" >_getNamespace(){return"NullTypes"}}</span>,rr=class extends tr{};vi(rr,"DbNull");var nr=class extends tr{};vi(nr,"JsonNull");var ir=class extends tr{};vi(ir,"AnyNull");var en={classes:{DbNull:rr,JsonNull:nr,AnyNull:ir},instances:{DbNull:new rr(Xr),JsonNull:new nr(Xr),AnyNull:new ir(Xr)}};function vi(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}var hs=Symbol(),or=class{constructor(t){if(t!==hs)<span class="branch-0 cbranch-no" title="branch not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" >i</span>fUndefined(t){return t===void 0?tn:t}}</span>,tn=new or(hs);<span class="fstat-no" title="function not covered" >function we(e){return e instanceof or}v</span>ar Ti=new WeakMap,sr=class{<span class="fstat-no" title="function not covered" >constructor(t,r){Ti.set(this,{sql:t,values:r})}<span class="fstat-no" title="function not covered" >g</span>et sql(){return Ti.get(this).sql}<span class="fstat-no" title="function not covered" >g</span>et values(){return Ti.get(this).values}}</span>;<span class="fstat-no" title="function not covered" >function ys(e){return(...t)=&gt;new sr(e,t)}<span class="fstat-no" title="function not covered" >f</span>unction ar(e){return{ok:!1,error:e,map(){return ar(e)},flatMap(){return ar(e)}}}v</span>ar Ri=class{<span class="fstat-no" title="function not covered" >constructor(){this.registeredErrors=[]}<span class="fstat-no" title="function not covered" >c</span>onsumeError(t){return this.registeredErrors[t]}<span class="fstat-no" title="function not covered" >r</span>egisterNewError(t){let r=0;for(;this.registeredErrors[r]!==void 0;)r++;return this.registeredErrors[r]={error:t},r}}</span>,Ci=<span class="fstat-no" title="function not covered" >e=&gt;{let t=new Ri,r=xe(t,e.transactionContext.bind(e)),n={adapterName:e.adapterName,errorRegistry:t,queryRaw:xe(t,e.queryRaw.bind(e)),executeRaw:xe(t,e.executeRaw.bind(e)),provider:e.provider,transactionContext:async(...i)=&gt;(await r(...i)).map(s=&gt;gc(t,s))};return e.getConnectionInfo&amp;&amp;(n.getConnectionInfo=yc(t,e.getConnectionInfo.bind(e))),n},</span>gc=<span class="fstat-no" title="function not covered" >(e,t)=&gt;{let r=xe(e,t.startTransaction.bind(t));return{adapterName:t.adapterName,provider:t.provider,queryRaw:xe(e,t.queryRaw.bind(t)),executeRaw:xe(e,t.executeRaw.bind(t)),startTransaction:async(...n)=&gt;(await r(...n)).map(o=&gt;hc(e,o))}},</span>hc=<span class="fstat-no" title="function not covered" >(e,t)=&gt;({adapterName:t.adapterName,provider:t.provider,options:t.options,queryRaw:xe(e,t.queryRaw.bind(t)),executeRaw:xe(e,t.executeRaw.bind(t)),commit:xe(e,t.commit.bind(t)),rollback:xe(e,t.rollback.bind(t))});<span class="fstat-no" title="function not covered" ></span>function xe(e,t){return async(...r)=&gt;{try{return await t(...r)}catch(n){let i=e.registerNewError(n);return ar({kind:"GenericJs",id:i})}}}<span class="fstat-no" title="function not covered" >f</span>unction yc(e,t){return(...r)=&gt;{try{return t(...r)}catch(n){let i=e.registerNewError(n);return ar({kind:"GenericJs",id:i})}}}v</span>ar Ul=k(ii());var Gl=require("async_hooks"),Ql=require("events"),Jl=k(require("fs")),_r=k(require("path"));var ie=class e{constructor(t,r){if(t.length-1!==r.length)<span class="branch-0 cbranch-no" title="branch not covered" >throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);l</span>et n=r.reduce((s,a)=&gt;s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];let i=0,o=0;for(;i&lt;r.length;)<span class="branch-0 cbranch-no" title="branch not covered" >{let s=r[i++],a=t[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l&lt;s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}<span class="fstat-no" title="function not covered" ></span>get sql(){let t=this.strings.length,r=1,n=this.strings[0];for(;r&lt;t;)n+=`?${this.strings[r++]}`;return n}<span class="fstat-no" title="function not covered" >g</span>et statement(){let t=this.strings.length,r=1,n=this.strings[0];for(;r&lt;t;)n+=`:${r}${this.strings[r++]}`;return n}<span class="fstat-no" title="function not covered" >g</span>et text(){let t=this.strings.length,r=1,n=this.strings[0];for(;r&lt;t;)n+=`$${r}${this.strings[r++]}`;return n}<span class="fstat-no" title="function not covered" >i</span>nspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}}</span>;<span class="fstat-no" title="function not covered" >function bs(e,t=",",r="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new ie([r,...Array(e.length-1).fill(t),n],e)}f</span>unction Si(e){return new ie([e],[])}var Es=Si("");<span class="fstat-no" title="function not covered" >function Ai(e,...t){return new ie(e,t)}<span class="fstat-no" title="function not covered" >f</span>unction lr(e){return{getKeys(){return Object.keys(e)},getPropertyValue(t){return e[t]}}}f</span>unction re(e,t){return{getKeys(){return[e]},<span class="fstat-no" title="function not covered" >getPropertyValue(){return t()}}</span>}var Pe=class{constructor(){this._map=new Map}<span class="fstat-no" title="function not covered" >get(t){return this._map.get(t)?.value}<span class="fstat-no" title="function not covered" >s</span>et(t,r){this._map.set(t,{value:r})}<span class="fstat-no" title="function not covered" >g</span>etOrCreate(t,r){let n=this._map.get(t);if(n)return n.value;let i=r();return this.set(t,i),i}}</span>;function it(e){let t=new Pe;return{getKeys(){return e.getKeys()},<span class="fstat-no" title="function not covered" >getPropertyValue(r){return t.getOrCreate(r,()=&gt;e.getPropertyValue(r))},<span class="fstat-no" title="function not covered" ></span>getPropertyDescriptor(r){return e.getPropertyDescriptor?.(r)}}</span>}var rn={enumerable:!0,configurable:!0,writable:!0};<span class="fstat-no" title="function not covered" >function nn(e){let t=new Set(e);return{getOwnPropertyDescriptor:()=&gt;rn,has:(r,n)=&gt;t.has(n),set:(r,n,i)=&gt;t.add(n)&amp;&amp;Reflect.set(r,n,i),ownKeys:()=&gt;[...t]}}v</span>ar ws=Symbol.for("nodejs.util.inspect.custom");function ve(e,t){let r=bc(t),n=new Set,i=new Proxy(e,{<span class="fstat-no" title="function not covered" >get(o,s){if(n.has(s))return o[s];let a=r.get(s);return a?a.getPropertyValue(s):o[s]},<span class="fstat-no" title="function not covered" ></span>has(o,s){if(n.has(s))return!0;let a=r.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},<span class="fstat-no" title="function not covered" ></span>ownKeys(o){let s=xs(Reflect.ownKeys(o),r),a=xs(Array.from(r.keys()),r);return[...new Set([...s,...a,...n])]},</span>set(o,s,a){return r.get(s)<span class="branch-0 cbranch-no" title="branch not covered" >?.getPropertyDescriptor?.(s)?.writable=</span>==!1<span class="branch-0 cbranch-no" title="branch not covered" >?!1:</span>(n.add(s),Reflect.set(o,s,a))},<span class="fstat-no" title="function not covered" >getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&amp;&amp;!a.configurable)return a;let l=r.get(s);return l?l.getPropertyDescriptor?{...rn,...l?.getPropertyDescriptor(s)}:rn:a},<span class="fstat-no" title="function not covered" ></span>defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)}}</span>);return i[ws]=<span class="fstat-no" title="function not covered" >function(){let o={...this};return delete o[ws],o},</span>i}function bc(e){let t=new Map;for(let r of e){let n=r.getKeys();for(let i of n)t.set(i,r)}return t}<span class="fstat-no" title="function not covered" >function xs(e,t){return e.filter(r=&gt;t.get(r)?.has?.(r)??!0)}<span class="fstat-no" title="function not covered" >f</span>unction Et(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}<span class="fstat-no" title="function not covered" >f</span>unction wt(e,t){return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}v</span>ar xt=class{<span class="fstat-no" title="function not covered" >constructor(t=0,r){this.context=r;this.lines=[];this.currentLine="";this.currentIndent=0;this.currentIndent=t}<span class="fstat-no" title="function not covered" >w</span>rite(t){return typeof t=="string"?this.currentLine+=t:t.write(this),this}<span class="fstat-no" title="function not covered" >w</span>riteJoined(t,r,n=(i,o)=&gt;o.write(i)){let i=r.length-1;for(let o=0;o&lt;r.length;o++)n(r[o],this),o!==i&amp;&amp;this.write(t);return this}<span class="fstat-no" title="function not covered" >w</span>riteLine(t){return this.write(t).newLine()}<span class="fstat-no" title="function not covered" >n</span>ewLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let t=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,t?.(),this}<span class="fstat-no" title="function not covered" >w</span>ithIndent(t){return this.indent(),t(this),this.unindent(),this}<span class="fstat-no" title="function not covered" >a</span>fterNextNewline(t){return this.afterNextNewLineCallback=t,this}<span class="fstat-no" title="function not covered" >i</span>ndent(){return this.currentIndent++,this}<span class="fstat-no" title="function not covered" >u</span>nindent(){return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}<span class="fstat-no" title="function not covered" >a</span>ddMarginSymbol(t){return this.marginSymbol=t,this}<span class="fstat-no" title="function not covered" >t</span>oString(){return this.lines.concat(this.indentedCurrentLine()).join(`</span>
`)}<span class="fstat-no" title="function not covered" >getCurrentLineLength(){return this.currentLine.length}<span class="fstat-no" title="function not covered" >i</span>ndentedCurrentLine(){let t=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+t.slice(1):t}}</span>;<span class="fstat-no" title="function not covered" >function Ps(e){return e.substring(0,1).toLowerCase()+e.substring(1)}<span class="fstat-no" title="function not covered" >f</span>unction Pt(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}<span class="fstat-no" title="function not covered" >f</span>unction on(e){return e.toString()!=="Invalid Date"}v</span>ar vt=9e15,ze=1e9,Ii="0123456789abcdef",an="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",ln="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Oi={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-vt,maxE:vt,crypto:!1},Cs,Me,x=!0,cn="[DecimalError] ",Ke=cn+"Invalid argument: ",Ss=cn+"Precision limit exceeded",As=cn+"crypto unavailable",Is="[object Decimal]",ee=Math.floor,G=Math.pow,Ec=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,wc=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,xc=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Os=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,ge=1e7,b=7,Pc=9007199254740991,vc=an.length-1,ki=ln.length-1,m={toStringTag:Is};m.absoluteValue=m.abs=<span class="fstat-no" title="function not covered" >function(){var e=new this.constructor(this);return e.s&lt;0&amp;&amp;(e.s=1),y(e)};m</span>.ceil=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,2)};m</span>.clampedTo=m.clamp=<span class="fstat-no" title="function not covered" >function(e,t){var r,n=this,i=n.constructor;if(e=new i(e),t=new i(t),!e.s||!t.s)return new i(NaN);if(e.gt(t))throw Error(Ke+t);return r=n.cmp(e),r&lt;0?e:n.cmp(t)&gt;0?t:new i(n)};m</span>.comparedTo=m.cmp=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?NaN:l!==u?l:s===a?0:!s^l&lt;0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e&gt;e.e^l&lt;0?1:-1;for(n=s.length,i=a.length,t=0,r=n&lt;i?n:i;t&lt;r;++t)if(s[t]!==a[t])return s[t]&gt;a[t]^l&lt;0?1:-1;return n===i?0:n&gt;i^l&lt;0?1:-1};m</span>.cosine=m.cos=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+b,n.rounding=1,r=Tc(n,Ls(n,r)),n.precision=e,n.rounding=t,y(Me==2||Me==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)};m</span>.cubeRoot=m.cbrt=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i,o,s,a,l,u,c=this,p=c.constructor;if(!c.isFinite()||c.isZero())return new p(c);for(x=!1,o=c.s*G(c.s*c,1/3),!o||Math.abs(o)==1/0?(r=K(c.d),e=c.e,(o=(e-r.length+1)%3)&amp;&amp;(r+=o==1||o==-2?"0":"00"),o=G(r,1/3),e=ee((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new p(r),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.plus(c),n=N(u.plus(c).times(a),u.plus(l),s+2,1),K(a.d).slice(0,s)===(r=K(n.d)).slice(0,s))if(r=r.slice(s-3,s+1),r=="9999"||!i&amp;&amp;r=="4999"){if(!i&amp;&amp;(y(a,e+1,0),a.times(a).times(a).eq(c))){n=a;break}s+=4,i=1}else{(!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(y(n,e+1,1),t=!n.times(n).times(n).eq(c));break}return x=!0,y(n,e,p.rounding,t)};m</span>.decimalPlaces=m.dp=<span class="fstat-no" title="function not covered" >function(){var e,t=this.d,r=NaN;if(t){if(e=t.length-1,r=(e-ee(this.e/b))*b,e=t[e],e)for(;e%10==0;e/=10)r--;r&lt;0&amp;&amp;(r=0)}return r};m</span>.dividedBy=m.div=<span class="fstat-no" title="function not covered" >function(e){return N(this,new this.constructor(e))};m</span>.dividedToIntegerBy=m.divToInt=<span class="fstat-no" title="function not covered" >function(e){var t=this,r=t.constructor;return y(N(t,new r(e),0,1,1),r.precision,r.rounding)};m</span>.equals=m.eq=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)===0};m</span>.floor=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,3)};m</span>.greaterThan=m.gt=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&gt;0};m</span>.greaterThanOrEqualTo=m.gte=<span class="fstat-no" title="function not covered" >function(e){var t=this.cmp(e);return t==1||t===0};m</span>.hyperbolicCosine=m.cosh=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;r=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),t=(1/dn(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=Tt(s,1,o.times(t),new s(1),!0);for(var l,u=e,c=new s(8);u--;)l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));return y(o,s.precision=r,s.rounding=n,!0)};m</span>.hyperbolicSine=m.sinh=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)i=Tt(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/dn(5,e)),i=Tt(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=t,o.rounding=r,y(i,t,r,!0)};m</span>.hyperbolicTangent=m.tanh=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,N(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)};m</span>.inverseCosine=m.acos=<span class="fstat-no" title="function not covered" >function(){var e,t=this,r=t.constructor,n=t.abs().cmp(1),i=r.precision,o=r.rounding;return n!==-1?n===0?t.isNeg()?fe(r,i,o):new r(0):new r(NaN):t.isZero()?fe(r,i+4,o).times(.5):(r.precision=i+6,r.rounding=1,t=t.asin(),e=fe(r,i+4,o).times(.5),r.precision=i,r.rounding=o,e.minus(t))};m</span>.inverseHyperbolicCosine=m.acosh=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,x=!1,r=r.times(r).minus(1).sqrt().plus(r),x=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)};m</span>.inverseHyperbolicSine=m.asinh=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,x=!1,r=r.times(r).plus(1).sqrt().plus(r),x=!0,n.precision=e,n.rounding=t,r.ln())};m</span>.inverseHyperbolicTangent=m.atanh=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i=this,o=i.constructor;return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?y(new o(i),e,t,!0):(o.precision=r=n-i.e,i=N(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)};m</span>.inverseSine=m.asin=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i=this,o=i.constructor;return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=fe(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))};m</span>.inverseTangent=m.atan=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding;if(u.isFinite()){if(u.isZero())return new c(u);if(u.abs().eq(1)&amp;&amp;p+4&lt;=ki)return s=fe(c,p+4,d).times(.25),s.s=u.s,s}else{if(!u.s)return new c(NaN);if(p+4&lt;=ki)return s=fe(c,p+4,d).times(.5),s.s=u.s,s}for(c.precision=a=p+10,c.rounding=1,r=Math.min(28,a/b+2|0),e=r;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(x=!1,t=Math.ceil(a/b),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)for(e=t;s.d[e]===o.d[e]&amp;&amp;e--;);return r&amp;&amp;(s=s.times(2&lt;&lt;r-1)),x=!0,y(s,c.precision=p,c.rounding=d,!0)};m</span>.isFinite=<span class="fstat-no" title="function not covered" >function(){return!!this.d};m</span>.isInteger=m.isInt=<span class="fstat-no" title="function not covered" >function(){return!!this.d&amp;&amp;ee(this.e/b)&gt;this.d.length-2};m</span>.isNaN=<span class="fstat-no" title="function not covered" >function(){return!this.s};m</span>.isNegative=m.isNeg=<span class="fstat-no" title="function not covered" >function(){return this.s&lt;0};m</span>.isPositive=m.isPos=<span class="fstat-no" title="function not covered" >function(){return this.s&gt;0};m</span>.isZero=<span class="fstat-no" title="function not covered" >function(){return!!this.d&amp;&amp;this.d[0]===0};m</span>.lessThan=m.lt=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&lt;0};m</span>.lessThanOrEqualTo=m.lte=<span class="fstat-no" title="function not covered" >function(e){return this.cmp(e)&lt;1};m</span>.logarithm=m.log=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding,f=5;if(e==null)e=new c(10),t=!0;else{if(e=new c(e),r=e.d,e.s&lt;0||!r||!r[0]||e.eq(1))return new c(NaN);t=e.eq(10)}if(r=u.d,u.s&lt;0||!r||!r[0]||u.eq(1))return new c(r&amp;&amp;!r[0]?-1/0:u.s!=1?NaN:r?0:1/0);if(t)if(r.length&gt;1)o=!0;else{for(i=r[0];i%10===0;)i/=10;o=i!==1}if(x=!1,a=p+f,s=He(u,a),n=t?un(c,a+10):He(e,a),l=N(s,n,a,1),ur(l.d,i=p,d))do if(a+=10,s=He(u,a),n=t?un(c,a+10):He(e,a),l=N(s,n,a,1),!o){+K(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=y(l,p+1,0));break}while(ur(l.d,i+=10,d));return x=!0,y(l,p,d)};m</span>.minus=m.sub=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a,l,u,c,p,d,f=this,g=f.constructor;if(e=new g(e),!f.d||!e.d)return!f.s||!e.s?e=new g(NaN):f.d?e.s=-e.s:e=new g(e.d||f.s!==e.s?f:NaN),e;if(f.s!=e.s)return e.s=-e.s,f.plus(e);if(u=f.d,d=e.d,a=g.precision,l=g.rounding,!u[0]||!d[0]){if(d[0])e.s=-e.s;else if(u[0])e=new g(f);else return new g(l===3?-0:0);return x?y(e,a,l):e}if(r=ee(e.e/b),c=ee(f.e/b),u=u.slice(),o=c-r,o){for(p=o&lt;0,p?(t=u,o=-o,s=d.length):(t=d,r=c,s=u.length),n=Math.max(Math.ceil(a/b),s)+2,o&gt;n&amp;&amp;(o=n,t.length=1),t.reverse(),n=o;n--;)t.push(0);t.reverse()}else{for(n=u.length,s=d.length,p=n&lt;s,p&amp;&amp;(s=n),n=0;n&lt;s;n++)if(u[n]!=d[n]){p=u[n]&lt;d[n];break}o=0}for(p&amp;&amp;(t=u,u=d,d=t,e.s=-e.s),s=u.length,n=d.length-s;n&gt;0;--n)u[s++]=0;for(n=d.length;n&gt;o;){if(u[--n]&lt;d[n]){for(i=n;i&amp;&amp;u[--i]===0;)u[i]=ge-1;--u[i],u[n]+=ge}u[n]-=d[n]}for(;u[--s]===0;)u.pop();for(;u[0]===0;u.shift())--r;return u[0]?(e.d=u,e.e=pn(u,r),x?y(e,a,l):e):new g(l===3?-0:0)};m</span>.modulo=m.mod=<span class="fstat-no" title="function not covered" >function(e){var t,r=this,n=r.constructor;return e=new n(e),!r.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||r.d&amp;&amp;!r.d[0]?y(new n(r),n.precision,n.rounding):(x=!1,n.modulo==9?(t=N(r,e.abs(),0,3,1),t.s*=e.s):t=N(r,e,0,n.modulo,1),t=t.times(e),x=!0,r.minus(t))};m</span>.naturalExponential=m.exp=<span class="fstat-no" title="function not covered" >function(){return Di(this)};m</span>.naturalLogarithm=m.ln=<span class="fstat-no" title="function not covered" >function(){return He(this)};m</span>.negated=m.neg=<span class="fstat-no" title="function not covered" >function(){var e=new this.constructor(this);return e.s=-e.s,y(e)};m</span>.plus=m.add=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a,l,u,c,p=this,d=p.constructor;if(e=new d(e),!p.d||!e.d)return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;if(p.s!=e.s)return e.s=-e.s,p.minus(e);if(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])return c[0]||(e=new d(p)),x?y(e,a,l):e;if(o=ee(p.e/b),n=ee(e.e/b),u=u.slice(),i=o-n,i){for(i&lt;0?(r=u,i=-i,s=c.length):(r=c,n=o,s=u.length),o=Math.ceil(a/b),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,r.length=1),r.reverse();i--;)r.push(0);r.reverse()}for(s=u.length,i=c.length,s-i&lt;0&amp;&amp;(i=s,r=c,c=u,u=r),t=0;i;)t=(u[--i]=u[i]+c[i]+t)/ge|0,u[i]%=ge;for(t&amp;&amp;(u.unshift(t),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=pn(u,n),x?y(e,a,l):e};m</span>.precision=m.sd=<span class="fstat-no" title="function not covered" >function(e){var t,r=this;if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)throw Error(Ke+e);return r.d?(t=ks(r.d),e&amp;&amp;r.e+1&gt;t&amp;&amp;(t=r.e+1)):t=NaN,t};m</span>.round=<span class="fstat-no" title="function not covered" >function(){var e=this,t=e.constructor;return y(new t(e),e.e+1,t.rounding)};m</span>.sine=m.sin=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+b,n.rounding=1,r=Cc(n,Ls(n,r)),n.precision=e,n.rounding=t,y(Me&gt;2?r.neg():r,e,t,!0)):new n(NaN)};m</span>.squareRoot=m.sqrt=<span class="fstat-no" title="function not covered" >function(){var e,t,r,n,i,o,s=this,a=s.d,l=s.e,u=s.s,c=s.constructor;if(u!==1||!a||!a[0])return new c(!u||u&lt;0&amp;&amp;(!a||a[0])?NaN:a?s:1/0);for(x=!1,u=Math.sqrt(+s),u==0||u==1/0?(t=K(a),(t.length+l)%2==0&amp;&amp;(t+="0"),u=Math.sqrt(t),l=ee((l+1)/2)-(l&lt;0||l%2),u==1/0?t="5e"+l:(t=u.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new c(t)):n=new c(u.toString()),r=(l=c.precision)+3;;)if(o=n,n=o.plus(N(s,o,r+2,1)).times(.5),K(o.d).slice(0,r)===(t=K(n.d)).slice(0,r))if(t=t.slice(r-3,r+1),t=="9999"||!i&amp;&amp;t=="4999"){if(!i&amp;&amp;(y(o,l+1,0),o.times(o).eq(s))){n=o;break}r+=4,i=1}else{(!+t||!+t.slice(1)&amp;&amp;t.charAt(0)=="5")&amp;&amp;(y(n,l+1,1),e=!n.times(n).eq(s));break}return x=!0,y(n,l,c.rounding,e)};m</span>.tangent=m.tan=<span class="fstat-no" title="function not covered" >function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=N(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,y(Me==2||Me==4?r.neg():r,e,t,!0)):new n(NaN)};m</span>.times=m.mul=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a,l,u,c=this,p=c.constructor,d=c.d,f=(e=new p(e)).d;if(e.s*=c.s,!d||!d[0]||!f||!f[0])return new p(!e.s||d&amp;&amp;!d[0]&amp;&amp;!f||f&amp;&amp;!f[0]&amp;&amp;!d?NaN:!d||!f?e.s/0:e.s*0);for(r=ee(c.e/b)+ee(e.e/b),l=d.length,u=f.length,l&lt;u&amp;&amp;(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.push(0);for(n=u;--n&gt;=0;){for(t=0,i=l+n;i&gt;n;)a=o[i]+f[n]*d[i-n-1]+t,o[i--]=a%ge|0,t=a/ge|0;o[i]=(o[i]+t)%ge|0}for(;!o[--s];)o.pop();return t?++r:o.shift(),e.d=o,e.e=pn(o,r),x?y(e,p.precision,p.rounding):e};m</span>.toBinary=<span class="fstat-no" title="function not covered" >function(e,t){return Fi(this,2,e,t)};m</span>.toDecimalPlaces=m.toDP=<span class="fstat-no" title="function not covered" >function(e,t){var r=this,n=r.constructor;return r=new n(r),e===void 0?r:(oe(e,0,ze),t===void 0?t=n.rounding:oe(t,0,8),y(r,e+r.e+1,t))};m</span>.toExponential=<span class="fstat-no" title="function not covered" >function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=Te(n,!0):(oe(e,0,ze),t===void 0?t=i.rounding:oe(t,0,8),n=y(new i(n),e+1,t),r=Te(n,!0,e+1)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r};m</span>.toFixed=<span class="fstat-no" title="function not covered" >function(e,t){var r,n,i=this,o=i.constructor;return e===void 0?r=Te(i):(oe(e,0,ze),t===void 0?t=o.rounding:oe(t,0,8),n=y(new o(i),e+i.e+1,t),r=Te(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!i.isZero()?"-"+r:r};m</span>.toFraction=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a,l,u,c,p,d,f=this,g=f.d,h=f.constructor;if(!g)return new h(f);if(u=r=new h(1),n=l=new h(0),t=new h(n),o=t.e=ks(g)-f.e-1,s=o%b,t.d[0]=G(10,s&lt;0?b+s:s),e==null)e=o&gt;0?t:u;else{if(a=new h(e),!a.isInt()||a.lt(u))throw Error(Ke+a);e=a.gt(t)?o&gt;0?t:u:a}for(x=!1,a=new h(K(g)),c=h.precision,h.precision=o=g.length*b*2;p=N(a,t,0,1,1),i=r.plus(p.times(n)),i.cmp(e)!=1;)r=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=t,t=a.minus(p.times(i)),a=i;return i=N(e.minus(r),n,0,1,1),l=l.plus(i.times(u)),r=r.plus(i.times(n)),l.s=u.s=f.s,d=N(u,n,o,1).minus(f).abs().cmp(N(l,r,o,1).minus(f).abs())&lt;1?[u,n]:[l,r],h.precision=c,x=!0,d};m</span>.toHexadecimal=m.toHex=<span class="fstat-no" title="function not covered" >function(e,t){return Fi(this,16,e,t)};m</span>.toNearest=<span class="fstat-no" title="function not covered" >function(e,t){var r=this,n=r.constructor;if(r=new n(r),e==null){if(!r.d)return r;e=new n(1),t=n.rounding}else{if(e=new n(e),t===void 0?t=n.rounding:oe(t,0,8),!r.d)return e.s?r:e;if(!e.d)return e.s&amp;&amp;(e.s=r.s),e}return e.d[0]?(x=!1,r=N(r,e,0,t,1).times(e),x=!0,y(r)):(e.s=r.s,r=e),r};m</span>.toNumber=<span class="fstat-no" title="function not covered" >function(){return+this};m</span>.toOctal=<span class="fstat-no" title="function not covered" >function(e,t){return Fi(this,8,e,t)};m</span>.toPower=m.pow=<span class="fstat-no" title="function not covered" >function(e){var t,r,n,i,o,s,a=this,l=a.constructor,u=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(G(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return y(a,n,o);if(t=ee(e.e/b),t&gt;=e.d.length-1&amp;&amp;(r=u&lt;0?-u:u)&lt;=Pc)return i=Ds(l,a,r,n),e.s&lt;0?new l(1).div(i):y(i,n,o);if(s=a.s,s&lt;0){if(t&lt;e.d.length-1)return new l(NaN);if(e.d[t]&amp;1||(s=1),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)return a.s=s,a}return r=G(+a,u),t=r==0||!isFinite(r)?ee(u*(Math.log("0."+K(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t&gt;l.maxE+1||t&lt;l.minE-1?new l(t&gt;0?s/0:0):(x=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=Di(e.times(He(a,n+r)),n),i.d&amp;&amp;(i=y(i,n+5,1),ur(i.d,n,o)&amp;&amp;(t=n+10,i=y(Di(e.times(He(a,t+r)),t),t+5,1),+K(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=y(i,n+1,0)))),i.s=s,x=!0,l.rounding=o,y(i,n,o))};m</span>.toPrecision=<span class="fstat-no" title="function not covered" >function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=Te(n,n.e&lt;=i.toExpNeg||n.e&gt;=i.toExpPos):(oe(e,1,ze),t===void 0?t=i.rounding:oe(t,0,8),n=y(new i(n),e,t),r=Te(n,e&lt;=n.e||n.e&lt;=i.toExpNeg,e)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r};m</span>.toSignificantDigits=m.toSD=<span class="fstat-no" title="function not covered" >function(e,t){var r=this,n=r.constructor;return e===void 0?(e=n.precision,t=n.rounding):(oe(e,1,ze),t===void 0?t=n.rounding:oe(t,0,8)),y(new n(r),e,t)};m</span>.toString=<span class="fstat-no" title="function not covered" >function(){var e=this,t=e.constructor,r=Te(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);return e.isNeg()&amp;&amp;!e.isZero()?"-"+r:r};m</span>.truncated=m.trunc=<span class="fstat-no" title="function not covered" >function(){return y(new this.constructor(this),this.e+1,1)};m</span>.valueOf=m.toJSON=<span class="fstat-no" title="function not covered" >function(){var e=this,t=e.constructor,r=Te(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);return e.isNeg()?"-"+r:r};<span class="fstat-no" title="function not covered" >f</span>unction K(e){var t,r,n,i=e.length-1,o="",s=e[0];if(i&gt;0){for(o+=s,t=1;t&lt;i;t++)n=e[t]+"",r=b-n.length,r&amp;&amp;(o+=We(r)),o+=n;s=e[t],n=s+"",r=b-n.length,r&amp;&amp;(o+=We(r))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}<span class="fstat-no" title="function not covered" >f</span>unction oe(e,t,r){if(e!==~~e||e&lt;t||e&gt;r)throw Error(Ke+e)}<span class="fstat-no" title="function not covered" >f</span>unction ur(e,t,r,n){var i,o,s,a;for(o=e[0];o&gt;=10;o/=10)--t;return--t&lt;0?(t+=b,i=0):(i=Math.ceil((t+1)/b),t%=b),o=G(10,b-t),a=e[i]%o|0,n==null?t&lt;3?(t==0?a=a/100|0:t==1&amp;&amp;(a=a/10|0),s=r&lt;4&amp;&amp;a==99999||r&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(r&lt;4&amp;&amp;a+1==o||r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==G(10,t-2)-1||(a==o/2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:t&lt;4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&amp;&amp;(a=a/10|0),s=(n||r&lt;4)&amp;&amp;a==9999||!n&amp;&amp;r&gt;3&amp;&amp;a==4999):s=((n||r&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==G(10,t-3)-1,s}<span class="fstat-no" title="function not covered" >f</span>unction sn(e,t,r){for(var n,i=[0],o,s=0,a=e.length;s&lt;a;){for(o=i.length;o--;)i[o]*=t;for(i[0]+=Ii.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)i[n]&gt;r-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}return i.reverse()}<span class="fstat-no" title="function not covered" >f</span>unction Tc(e,t){var r,n,i;if(t.isZero())return t;n=t.d.length,n&lt;32?(r=Math.ceil(n/3),i=(1/dn(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=Tt(e,1,t.times(i),new e(1));for(var o=r;o--;){var s=t.times(t);t=s.times(s).minus(s).times(8).plus(1)}return e.precision-=r,t}v</span>ar N=function(){<span class="fstat-no" title="function not covered" >function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&amp;&amp;n.unshift(a),n}<span class="fstat-no" title="function not covered" >f</span>unction t(n,i,o,s){var a,l;if(o!=s)l=o&gt;s?1:-1;else for(a=l=0;a&lt;o;a++)if(n[a]!=i[a]){l=n[a]&gt;i[a]?1:-1;break}return l}<span class="fstat-no" title="function not covered" >f</span>unction r(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&amp;&amp;n.length&gt;1;)n.shift()}r</span>eturn function(n,i,o,s,a,l){var u,c,p,d,f,g,h,O,T,S,C,E,me,ae,jt,U,ne,Ie,z,dt,Fr=n.constructor,$n=n.s==i.s?1:-1,Y=n.d,_=i.d;if(!Y||!Y[0]||!_||!_[0])return new Fr(!n.s||!i.s||(Y?_&amp;&amp;Y[0]==_[0]:!_)?NaN:Y&amp;&amp;Y[0]==0||!_?$n*0:$n/0);for(l?(f=1,c=n.e-i.e):(l=ge,f=b,c=ee(n.e/f)-ee(i.e/f)),z=_.length,ne=Y.length,T=new Fr($n),S=T.d=[],p=0;_[p]==(Y[p]||0);p++);if(_[p]&gt;(Y[p]||0)&amp;&amp;c--,o==null?(ae=o=Fr.precision,s=Fr.rounding):a?ae=o+(n.e-i.e)+1:ae=o,ae&lt;0)S.push(1),g=!0;else{if(ae=ae/f+2|0,p=0,z==1){for(d=0,_=_[0],ae++;(p&lt;ne||d)&amp;&amp;ae--;p++)jt=d*l+(Y[p]||0),S[p]=jt/_|0,d=jt%_|0;g=d||p&lt;ne}else{for(d=l/(_[0]+1)|0,d&gt;1&amp;&amp;(_=e(_,d,l),Y=e(Y,d,l),z=_.length,ne=Y.length),U=z,C=Y.slice(0,z),E=C.length;E&lt;z;)C[E++]=0;dt=_.slice(),dt.unshift(0),Ie=_[0],_[1]&gt;=l/2&amp;&amp;++Ie;do d=0,u=t(_,C,z,E),u&lt;0?(me=C[0],z!=E&amp;&amp;(me=me*l+(C[1]||0)),d=me/Ie|0,d&gt;1?(d&gt;=l&amp;&amp;(d=l-1),h=e(_,d,l),O=h.length,E=C.length,u=t(h,C,O,E),u==1&amp;&amp;(d--,r(h,z&lt;O?dt:_,O,l))):(d==0&amp;&amp;(u=d=1),h=_.slice()),O=h.length,O&lt;E&amp;&amp;h.unshift(0),r(C,h,E,l),u==-1&amp;&amp;(E=C.length,u=t(_,C,z,E),u&lt;1&amp;&amp;(d++,r(C,z&lt;E?dt:_,E,l))),E=C.length):u===0&amp;&amp;(d++,C=[0]),S[p++]=d,u&amp;&amp;C[0]?C[E++]=Y[U]||0:(C=[Y[U]],E=1);while((U++&lt;ne||C[0]!==void 0)&amp;&amp;ae--);g=C[0]!==void 0}S[0]||S.shift()}if(f==1)T.e=c,Cs=g;else{for(p=1,d=S[0];d&gt;=10;d/=10)p++;T.e=p+c*f-1,y(T,a?o+T.e+1:o,s,g)}return T}}();<span class="fstat-no" title="function not covered" >function y(e,t,r,n){var i,o,s,a,l,u,c,p,d,f=e.constructor;e:if(t!=null){if(p=e.d,!p)return e;for(i=1,a=p[0];a&gt;=10;a/=10)i++;if(o=t-i,o&lt;0)o+=b,s=t,c=p[d=0],l=c/G(10,i-s-1)%10|0;else if(d=Math.ceil((o+1)/b),a=p.length,d&gt;=a)if(n){for(;a++&lt;=d;)p.push(0);c=l=0,i=1,o%=b,s=o-b+1}else break e;else{for(c=a=p[d],i=1;a&gt;=10;a/=10)i++;o%=b,s=o-b+i,l=s&lt;0?0:c/G(10,i-s-1)%10|0}if(n=n||t&lt;0||p[d+1]!==void 0||(s&lt;0?c:c%G(10,i-s-1)),u=r&lt;4?(l||n)&amp;&amp;(r==0||r==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(r==4||n||r==6&amp;&amp;(o&gt;0?s&gt;0?c/G(10,i-s):0:p[d-1])%10&amp;1||r==(e.s&lt;0?8:7)),t&lt;1||!p[0])return p.length=0,u?(t-=e.e+1,p[0]=G(10,(b-t%b)%b),e.e=-t||0):p[0]=e.e=0,e;if(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=G(10,b-o),p[d]=s&gt;0?(c/G(10,i-s)%G(10,s)|0)*a:0),u)for(;;)if(d==0){for(o=1,s=p[0];s&gt;=10;s/=10)o++;for(s=p[0]+=a,a=1;s&gt;=10;s/=10)a++;o!=a&amp;&amp;(e.e++,p[0]==ge&amp;&amp;(p[0]=1));break}else{if(p[d]+=a,p[d]!=ge)break;p[d--]=0,a=1}for(o=p.length;p[--o]===0;)p.pop()}return x&amp;&amp;(e.e&gt;f.maxE?(e.d=null,e.e=NaN):e.e&lt;f.minE&amp;&amp;(e.e=0,e.d=[0])),e}<span class="fstat-no" title="function not covered" >f</span>unction Te(e,t,r){if(!e.isFinite())return Fs(e);var n,i=e.e,o=K(e.d),s=o.length;return t?(r&amp;&amp;(n=r-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+We(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i&lt;0?(o="0."+We(-i-1)+o,r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(o+=We(n))):i&gt;=s?(o+=We(i+1-s),r&amp;&amp;(n=r-i-1)&gt;0&amp;&amp;(o=o+"."+We(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=We(n))),o}<span class="fstat-no" title="function not covered" >f</span>unction pn(e,t){var r=e[0];for(t*=b;r&gt;=10;r/=10)t++;return t}<span class="fstat-no" title="function not covered" >f</span>unction un(e,t,r){if(t&gt;vc)throw x=!0,r&amp;&amp;(e.precision=r),Error(Ss);return y(new e(an),t,1,!0)}<span class="fstat-no" title="function not covered" >f</span>unction fe(e,t,r){if(t&gt;ki)throw Error(Ss);return y(new e(ln),t,r,!0)}<span class="fstat-no" title="function not covered" >f</span>unction ks(e){var t=e.length-1,r=t*b+1;if(t=e[t],t){for(;t%10==0;t/=10)r--;for(t=e[0];t&gt;=10;t/=10)r++}return r}<span class="fstat-no" title="function not covered" >f</span>unction We(e){for(var t="";e--;)t+="0";return t}<span class="fstat-no" title="function not covered" >f</span>unction Ds(e,t,r,n){var i,o=new e(1),s=Math.ceil(n/b+4);for(x=!1;;){if(r%2&amp;&amp;(o=o.times(t),Ts(o.d,s)&amp;&amp;(i=!0)),r=ee(r/2),r===0){r=o.d.length-1,i&amp;&amp;o.d[r]===0&amp;&amp;++o.d[r];break}t=t.times(t),Ts(t.d,s)}return x=!0,o}<span class="fstat-no" title="function not covered" >f</span>unction vs(e){return e.d[e.d.length-1]&amp;1}<span class="fstat-no" title="function not covered" >f</span>unction _s(e,t,r){for(var n,i=new e(t[0]),o=0;++o&lt;t.length;)if(n=new e(t[o]),n.s)i[r](n)&amp;&amp;(i=n);else{i=n;break}return i}<span class="fstat-no" title="function not covered" >f</span>unction Di(e,t){var r,n,i,o,s,a,l,u=0,c=0,p=0,d=e.constructor,f=d.rounding,g=d.precision;if(!e.d||!e.d[0]||e.e&gt;17)return new d(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);for(t==null?(x=!1,l=g):l=t,a=new d(.03125);e.e&gt;-2;)e=e.times(a),p+=5;for(n=Math.log(G(2,p))/Math.LN10*2+5|0,l+=n,r=o=s=new d(1),d.precision=l;;){if(o=y(o.times(e),l,1),r=r.times(++c),a=s.plus(N(o,r,l,1)),K(a.d).slice(0,l)===K(s.d).slice(0,l)){for(i=p;i--;)s=y(s.times(s),l,1);if(t==null)if(u&lt;3&amp;&amp;ur(s.d,l-n,f,u))d.precision=l+=10,r=o=a=new d(1),c=0,u++;else return y(s,d.precision=g,f,x=!0);else return d.precision=g,s}s=a}}<span class="fstat-no" title="function not covered" >f</span>unction He(e,t){var r,n,i,o,s,a,l,u,c,p,d,f=1,g=10,h=e,O=h.d,T=h.constructor,S=T.rounding,C=T.precision;if(h.s&lt;0||!O||!O[0]||!h.e&amp;&amp;O[0]==1&amp;&amp;O.length==1)return new T(O&amp;&amp;!O[0]?-1/0:h.s!=1?NaN:O?0:h);if(t==null?(x=!1,c=C):c=t,T.precision=c+=g,r=K(O),n=r.charAt(0),Math.abs(o=h.e)&lt;15e14){for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;r.charAt(1)&gt;3;)h=h.times(e),r=K(h.d),n=r.charAt(0),f++;o=h.e,n&gt;1?(h=new T("0."+r),o++):h=new T(n+"."+r.slice(1))}else return u=un(T,c+2,C).times(o+""),h=He(new T(n+"."+r.slice(1)),c-g).plus(u),T.precision=C,t==null?y(h,C,S,x=!0):h;for(p=h,l=s=h=N(h.minus(1),h.plus(1),c,1),d=y(h.times(h),c,1),i=3;;){if(s=y(s.times(d),c,1),u=l.plus(N(s,new T(i),c,1)),K(u.d).slice(0,c)===K(l.d).slice(0,c))if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(un(T,c+2,C).times(o+""))),l=N(l,new T(f),c,1),t==null)if(ur(l.d,c-g,S,a))T.precision=c+=g,u=s=h=N(p.minus(1),p.plus(1),c,1),d=y(h.times(h),c,1),i=a=1;else return y(l,T.precision=C,S,x=!0);else return T.precision=C,l;l=u,i+=2}}<span class="fstat-no" title="function not covered" >f</span>unction Fs(e){return String(e.s*e.s/0)}f</span>unction _i(e,t){var r,n,i;for((r=t.indexOf("."))&gt;-1&amp;&amp;(t=t.replace(".","")),(n=t.search(/e/i))&gt;0<span class="branch-0 cbranch-no" title="branch not covered" >?(r&lt;0&amp;&amp;(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r</span>&lt;0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(r=t.length),</span>n=0;t.charCodeAt(n)===48;n++)<span class="branch-0 cbranch-no" title="branch not covered" >;f</span>or(i=t.length;t.charCodeAt(i-1)===48;--i)<span class="branch-0 cbranch-no" title="branch not covered" >;i</span>f(t=t.slice(n,i),t){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%b,r&lt;0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(n+=b),</span>n&lt;i){for(n&amp;&amp;e.d.push(+t.slice(0,n)),i-=b;n&lt;i;)e.d.push(+t.slice(n,n+=b));t=t.slice(n),n=b-t.length}<span class="branch-0 cbranch-no" title="branch not covered" >else n-=i;f</span>or(;n--;)t+="0";e.d.push(+t),x&amp;&amp;(e.e&gt;e.constructor.maxE<span class="branch-0 cbranch-no" title="branch not covered" >?(e.d=null,e.e=NaN):e</span>.e&lt;e.constructor.minE<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(e.e=0,e.d=[0]))</span>}<span class="branch-0 cbranch-no" title="branch not covered" >else e.e=0,e.d=[0];r</span>eturn e}<span class="fstat-no" title="function not covered" >function Rc(e,t){var r,n,i,o,s,a,l,u,c;if(t.indexOf("_")&gt;-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),Os.test(t))return _i(e,t)}else if(t==="Infinity"||t==="NaN")return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(wc.test(t))r=16,t=t.toLowerCase();else if(Ec.test(t))r=2;else if(xc.test(t))r=8;else throw Error(Ke+t);for(o=t.search(/p/i),o&gt;0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(t=t.replace(".",""),a=t.length,o=a-o,i=Ds(n,new n(r),o,o*2)),u=sn(t,r,ge),c=u.length-1,o=c;u[o]===0;--o)u.pop();return o&lt;0?new n(e.s*0):(e.e=pn(u,c),e.d=u,x=!1,s&amp;&amp;(e=N(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?G(2,l):ot.pow(2,l))),x=!0,e)}<span class="fstat-no" title="function not covered" >f</span>unction Cc(e,t){var r,n=t.d.length;if(n&lt;3)return t.isZero()?t:Tt(e,2,t,t);r=1.4*Math.sqrt(n),r=r&gt;16?16:r|0,t=t.times(1/dn(5,r)),t=Tt(e,2,t,t);for(var i,o=new e(5),s=new e(16),a=new e(20);r--;)i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));return t}<span class="fstat-no" title="function not covered" >f</span>unction Tt(e,t,r,n,i){var o,s,a,l,u=1,c=e.precision,p=Math.ceil(c/b);for(x=!1,l=r.times(r),a=new e(n);;){if(s=N(a.times(l),new e(t++*t++),c,1),a=i?n.plus(s):n.minus(s),n=N(s.times(l),new e(t++*t++),c,1),s=a.plus(n),s.d[p]!==void 0){for(o=p;s.d[o]===a.d[o]&amp;&amp;o--;);if(o==-1)break}o=a,a=n,n=s,s=o,u++}return x=!0,s.d.length=p+1,s}<span class="fstat-no" title="function not covered" >f</span>unction dn(e,t){for(var r=e;--t;)r*=e;return r}<span class="fstat-no" title="function not covered" >f</span>unction Ls(e,t){var r,n=t.s&lt;0,i=fe(e,e.precision,1),o=i.times(.5);if(t=t.abs(),t.lte(o))return Me=n?4:1,t;if(r=t.divToInt(i),r.isZero())Me=n?3:2;else{if(t=t.minus(r.times(i)),t.lte(o))return Me=vs(r)?n?2:3:n?4:1,t;Me=vs(r)?n?1:4:n?3:2}return t.minus(i).abs()}<span class="fstat-no" title="function not covered" >f</span>unction Fi(e,t,r,n){var i,o,s,a,l,u,c,p,d,f=e.constructor,g=r!==void 0;if(g?(oe(r,1,ze),n===void 0?n=f.rounding:oe(n,0,8)):(r=f.precision,n=f.rounding),!e.isFinite())c=Fs(e);else{for(c=Te(e),s=c.indexOf("."),g?(i=2,t==16?r=r*4-3:t==8&amp;&amp;(r=r*3-2)):i=t,s&gt;=0&amp;&amp;(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=sn(Te(d),10,i),d.e=d.d.length),p=sn(c,10,i),o=l=p.length;p[--l]==0;)p.pop();if(!p[0])c=g?"0p+0":"0";else{if(s&lt;0?o--:(e=new f(e),e.d=p,e.e=o,e=N(e,d,r,n,0,i),p=e.d,o=e.e,u=Cs),s=p[r],a=i/2,u=u||p[r+1]!==void 0,u=n&lt;4?(s!==void 0||u)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||u||n===6&amp;&amp;p[r-1]&amp;1||n===(e.s&lt;0?8:7)),p.length=r,u)for(;++p[--r]&gt;i-1;)p[r]=0,r||(++o,p.unshift(1));for(l=p.length;!p[l-1];--l);for(s=0,c="";s&lt;l;s++)c+=Ii.charAt(p[s]);if(g){if(l&gt;1)if(t==16||t==8){for(s=t==16?4:3,--l;l%s;l++)c+="0";for(p=sn(c,i,t),l=p.length;!p[l-1];--l);for(s=1,c="1.";s&lt;l;s++)c+=Ii.charAt(p[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(o&lt;0?"p":"p+")+o}else if(o&lt;0){for(;++o;)c="0"+c;c="0."+c}else if(++o&gt;l)for(o-=l;o--;)c+="0";else o&lt;l&amp;&amp;(c=c.slice(0,o)+"."+c.slice(o))}c=(t==16?"0x":t==2?"0b":t==8?"0o":"")+c}return e.s&lt;0?"-"+c:c}<span class="fstat-no" title="function not covered" >f</span>unction Ts(e,t){if(e.length&gt;t)return e.length=t,!0}<span class="fstat-no" title="function not covered" >f</span>unction Sc(e){return new this(e).abs()}<span class="fstat-no" title="function not covered" >f</span>unction Ac(e){return new this(e).acos()}<span class="fstat-no" title="function not covered" >f</span>unction Ic(e){return new this(e).acosh()}<span class="fstat-no" title="function not covered" >f</span>unction Oc(e,t){return new this(e).plus(t)}<span class="fstat-no" title="function not covered" >f</span>unction kc(e){return new this(e).asin()}<span class="fstat-no" title="function not covered" >f</span>unction Dc(e){return new this(e).asinh()}<span class="fstat-no" title="function not covered" >f</span>unction _c(e){return new this(e).atan()}<span class="fstat-no" title="function not covered" >f</span>unction Fc(e){return new this(e).atanh()}<span class="fstat-no" title="function not covered" >f</span>unction Lc(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,o=n+4;return!e.s||!t.s?r=new this(NaN):!e.d&amp;&amp;!t.d?(r=fe(this,o,1).times(t.s&gt;0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s&lt;0?fe(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=fe(this,o,1).times(.5),r.s=e.s):t.s&lt;0?(this.precision=o,this.rounding=1,r=this.atan(N(e,t,o,1)),t=fe(this,o,1),this.precision=n,this.rounding=i,r=e.s&lt;0?r.minus(t):r.plus(t)):r=this.atan(N(e,t,o,1)),r}<span class="fstat-no" title="function not covered" >f</span>unction Nc(e){return new this(e).cbrt()}<span class="fstat-no" title="function not covered" >f</span>unction Mc(e){return y(e=new this(e),e.e+1,2)}<span class="fstat-no" title="function not covered" >f</span>unction $c(e,t,r){return new this(e).clamp(t,r)}f</span>unction qc(e){if(!e||typeof e!="object")<span class="branch-0 cbranch-no" title="branch not covered" >throw Error(cn+"Object expected");v</span>ar t,r,n,i=e.defaults===!0,o=["precision",1,ze,"rounding",0,8,"toExpNeg",-vt,0,"toExpPos",0,vt,"maxE",0,vt,"minE",-vt,0,"modulo",0,9];for(t=0;t&lt;o.length;t+=3)if(r=o[t],i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this[r]=Oi[r]),</span>(n=e[r])!==void 0)if(ee(n)===n&amp;&amp;n&gt;=o[t+1]&amp;&amp;n&lt;=o[t+2])this[r]=n;<span class="branch-0 cbranch-no" title="branch not covered" >else throw Error(Ke+r+": "+n);i</span>f(r="crypto",i<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this[r]=Oi[r]),</span>(n=e[r])!==void 0)if(n===!0||n===!1<span class="branch-0 cbranch-no" title="branch not covered" >||n===0<span class="branch-0 cbranch-no" title="branch not covered" >|</span>|n===1)</span>if(n<span class="branch-0 cbranch-no" title="branch not covered" >)if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))this[r]=!0;else throw Error(As);else t</span>his[r]=!1;<span class="branch-0 cbranch-no" title="branch not covered" >else throw Error(Ke+r+": "+n);r</span>eturn this}<span class="fstat-no" title="function not covered" >function jc(e){return new this(e).cos()}<span class="fstat-no" title="function not covered" >f</span>unction Vc(e){return new this(e).cosh()}f</span>unction Ns(e){var t,r,n;function i(o){var s,a,l,u=this;if(!(u instanceof i))<span class="branch-0 cbranch-no" title="branch not covered" >return new i(o);i</span>f(u.constructor=i,Rs(o))<span class="branch-0 cbranch-no" title="branch not covered" >{u.s=o.s,x?!o.d||o.e&gt;i.maxE?(u.e=NaN,u.d=null):o.e&lt;i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}i</span>f(l=typeof o,l==="number")<span class="branch-0 cbranch-no" title="branch not covered" >{if(o===0){u.s=1/o&lt;0?-1:1,u.e=0,u.d=[0];return}if(o&lt;0?(o=-o,u.s=-1):u.s=1,o===~~o&amp;&amp;o&lt;1e7){for(s=0,a=o;a&gt;=10;a/=10)s++;x?s&gt;i.maxE?(u.e=NaN,u.d=null):s&lt;i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}else if(o*0!==0){o||(u.s=NaN),u.e=NaN,u.d=null;return}return _i(u,o.toString())}e</span>lse if(l!=="string")<span class="branch-0 cbranch-no" title="branch not covered" >throw Error(Ke+o);r</span>eturn(a=o.charCodeAt(0))===45<span class="branch-0 cbranch-no" title="branch not covered" >?(o=o.slice(1),u.s=-1):(a</span>===43<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(o=o.slice(1)),</span>u.s=1),Os.test(o)?_i(u,o)<span class="branch-0 cbranch-no" title="branch not covered" >:Rc(u,o)}</span>if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=qc,i.clone=Ns,i.isDecimal=Rs,i.abs=Sc,i.acos=Ac,i.acosh=Ic,i.add=Oc,i.asin=kc,i.asinh=Dc,i.atan=_c,i.atanh=Fc,i.atan2=Lc,i.cbrt=Nc,i.ceil=Mc,i.clamp=$c,i.cos=jc,i.cosh=Vc,i.div=Bc,i.exp=Uc,i.floor=Gc,i.hypot=Qc,i.ln=Jc,i.log=Wc,i.log10=Kc,i.log2=Hc,i.max=zc,i.min=Yc,i.mod=Zc,i.mul=Xc,i.pow=ep,i.random=tp,i.round=rp,i.sign=np,i.sin=ip,i.sinh=op,i.sqrt=sp,i.sub=ap,i.sum=lp,i.tan=up,i.tanh=cp,i.trunc=pp,e===void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(e={}),</span>e&amp;&amp;e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t&lt;n.length;)e.hasOwnProperty(r=n[t++])<span class="branch-0 cbranch-no" title="branch not covered" >||(e[r]=this[r]);</span>return i.config(e),i}<span class="fstat-no" title="function not covered" >function Bc(e,t){return new this(e).div(t)}<span class="fstat-no" title="function not covered" >f</span>unction Uc(e){return new this(e).exp()}<span class="fstat-no" title="function not covered" >f</span>unction Gc(e){return y(e=new this(e),e.e+1,3)}<span class="fstat-no" title="function not covered" >f</span>unction Qc(){var e,t,r=new this(0);for(x=!1,e=0;e&lt;arguments.length;)if(t=new this(arguments[e++]),t.d)r.d&amp;&amp;(r=r.plus(t.times(t)));else{if(t.s)return x=!0,new this(1/0);r=t}return x=!0,r.sqrt()}f</span>unction Rs(e){return e instanceof ot||e&amp;&amp;e.toStringTag===Is||!1}<span class="fstat-no" title="function not covered" >function Jc(e){return new this(e).ln()}<span class="fstat-no" title="function not covered" >f</span>unction Wc(e,t){return new this(e).log(t)}<span class="fstat-no" title="function not covered" >f</span>unction Hc(e){return new this(e).log(2)}<span class="fstat-no" title="function not covered" >f</span>unction Kc(e){return new this(e).log(10)}<span class="fstat-no" title="function not covered" >f</span>unction zc(){return _s(this,arguments,"lt")}<span class="fstat-no" title="function not covered" >f</span>unction Yc(){return _s(this,arguments,"gt")}<span class="fstat-no" title="function not covered" >f</span>unction Zc(e,t){return new this(e).mod(t)}<span class="fstat-no" title="function not covered" >f</span>unction Xc(e,t){return new this(e).mul(t)}<span class="fstat-no" title="function not covered" >f</span>unction ep(e,t){return new this(e).pow(t)}<span class="fstat-no" title="function not covered" >f</span>unction tp(e){var t,r,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:oe(e,1,ze),n=Math.ceil(e/b),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)i=t[o],i&gt;=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(t=crypto.randomBytes(n*=4);o&lt;n;)i=t[o]+(t[o+1]&lt;&lt;8)+(t[o+2]&lt;&lt;16)+((t[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(As);else for(;o&lt;n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=b,n&amp;&amp;e&amp;&amp;(i=G(10,b-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o&lt;0)r=0,a=[0];else{for(r=-1;a[0]===0;r-=b)a.shift();for(n=1,i=a[0];i&gt;=10;i/=10)n++;n&lt;b&amp;&amp;(r-=b-n)}return s.e=r,s.d=a,s}<span class="fstat-no" title="function not covered" >f</span>unction rp(e){return y(e=new this(e),e.e+1,this.rounding)}<span class="fstat-no" title="function not covered" >f</span>unction np(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}<span class="fstat-no" title="function not covered" >f</span>unction ip(e){return new this(e).sin()}<span class="fstat-no" title="function not covered" >f</span>unction op(e){return new this(e).sinh()}<span class="fstat-no" title="function not covered" >f</span>unction sp(e){return new this(e).sqrt()}<span class="fstat-no" title="function not covered" >f</span>unction ap(e,t){return new this(e).sub(t)}<span class="fstat-no" title="function not covered" >f</span>unction lp(){var e=0,t=arguments,r=new this(t[e]);for(x=!1;r.s&amp;&amp;++e&lt;t.length;)r=r.plus(t[e]);return x=!0,y(r,this.precision,this.rounding)}<span class="fstat-no" title="function not covered" >f</span>unction up(e){return new this(e).tan()}<span class="fstat-no" title="function not covered" >f</span>unction cp(e){return new this(e).tanh()}<span class="fstat-no" title="function not covered" >f</span>unction pp(e){return y(e=new this(e),e.e+1,1)}m</span>[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var ot=m.constructor=Ns(Oi);an=new ot(an);ln=new ot(ln);var Re=ot;<span class="fstat-no" title="function not covered" >function Rt(e){return ot.isDecimal(e)?!0:e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;typeof e.e=="number"&amp;&amp;typeof e.toFixed=="function"&amp;&amp;Array.isArray(e.d)}v</span>ar cr=class{<span class="fstat-no" title="function not covered" >constructor(t,r,n,i,o){this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" >_</span>toGraphQLInputType(){let t=this.isList?"List":"",r=this.isEnum?"Enum":"";return`${t}${r}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}}</span>;<span class="fstat-no" title="function not covered" >function Ct(e){return e instanceof cr}v</span>ar mn=class{<span class="fstat-no" title="function not covered" >constructor(t){this.value=t}<span class="fstat-no" title="function not covered" >w</span>rite(t){t.write(this.value)}<span class="fstat-no" title="function not covered" >m</span>arkAsError(){this.value.markAsError()}}</span>;var fn=<span class="fstat-no" title="function not covered" >e=&gt;e,</span>gn={bold:fn,red:fn,green:fn,dim:fn,enabled:!1},Ms={bold:H,red:ce,green:qe,dim:Oe,enabled:!0},St={<span class="fstat-no" title="function not covered" >write(e){e.writeLine(",")}}</span>;var Ce=class{<span class="fstat-no" title="function not covered" >constructor(t){this.contents=t;this.isUnderlined=!1;this.color=t=&gt;t}<span class="fstat-no" title="function not covered" >u</span>nderline(){return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" >s</span>etColor(t){return this.color=t,this}<span class="fstat-no" title="function not covered" >w</span>rite(t){let r=t.getCurrentLineLength();t.write(this.color(this.contents)),this.isUnderlined&amp;&amp;t.afterNextNewline(()=&gt;{t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))})}}</span>;var Ye=class{<span class="fstat-no" title="function not covered" >constructor(){this.hasError=!1}<span class="fstat-no" title="function not covered" >m</span>arkAsError(){return this.hasError=!0,this}}</span>;var At=class extends Ye{<span class="fstat-no" title="function not covered" >constructor(){super(...arguments);this.items=[]}<span class="fstat-no" title="function not covered" >a</span>ddItem(r){return this.items.push(new mn(r)),this}<span class="fstat-no" title="function not covered" >g</span>etField(r){return this.items[r]}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(n=&gt;n.value.getPrintWidth()))+2}<span class="fstat-no" title="function not covered" >w</span>rite(r){if(this.items.length===0){this.writeEmpty(r);return}this.writeWithItems(r)}<span class="fstat-no" title="function not covered" >w</span>riteEmpty(r){let n=new Ce("[]");this.hasError&amp;&amp;n.setColor(r.context.colors.red).underline(),r.write(n)}<span class="fstat-no" title="function not covered" >w</span>riteWithItems(r){let{colors:n}=r.context;r.writeLine("[").withIndent(()=&gt;r.writeJoined(St,this.items).newLine()).write("]"),this.hasError&amp;&amp;r.afterNextNewline(()=&gt;{r.writeLine(n.red("~".repeat(this.getPrintWidth())))})}<span class="fstat-no" title="function not covered" >a</span>sObject(){}}</span>;var $s=": ",hn=class{<span class="fstat-no" title="function not covered" >constructor(t,r){this.name=t;this.value=r;this.hasError=!1}<span class="fstat-no" title="function not covered" >m</span>arkAsError(){this.hasError=!0}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){return this.name.length+this.value.getPrintWidth()+$s.length}<span class="fstat-no" title="function not covered" >w</span>rite(t){let r=new Ce(this.name);this.hasError&amp;&amp;r.underline().setColor(t.context.colors.red),t.write(r).write($s).write(this.value)}}</span>;var It=class e extends Ye{<span class="fstat-no" title="function not covered" >constructor(){super(...arguments);this.fields={};this.suggestions=[]}<span class="fstat-no" title="function not covered" >a</span>ddField(r){this.fields[r.name]=r}<span class="fstat-no" title="function not covered" >a</span>ddSuggestion(r){this.suggestions.push(r)}<span class="fstat-no" title="function not covered" >g</span>etField(r){return this.fields[r]}<span class="fstat-no" title="function not covered" >g</span>etDeepField(r){let[n,...i]=r,o=this.getField(n);if(!o)return;let s=o;for(let a of i){let l;if(s.value instanceof e?l=s.value.getField(a):s.value instanceof At&amp;&amp;(l=s.value.getField(Number(a))),!l)return;s=l}return s}<span class="fstat-no" title="function not covered" >g</span>etDeepFieldValue(r){return r.length===0?this:this.getDeepField(r)?.value}<span class="fstat-no" title="function not covered" >h</span>asField(r){return!!this.getField(r)}<span class="fstat-no" title="function not covered" >r</span>emoveAllFields(){this.fields={}}<span class="fstat-no" title="function not covered" >r</span>emoveField(r){delete this.fields[r]}<span class="fstat-no" title="function not covered" >g</span>etFields(){return this.fields}<span class="fstat-no" title="function not covered" >i</span>sEmpty(){return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" >g</span>etFieldValue(r){return this.getField(r)?.value}<span class="fstat-no" title="function not covered" >g</span>etDeepSubSelectionValue(r){let n=this;for(let i of r){if(!(n instanceof e))return;let o=n.getSubSelectionValue(i);if(!o)return;n=o}return n}<span class="fstat-no" title="function not covered" >g</span>etDeepSelectionParent(r){let n=this.getSelectionParent();if(!n)return;let i=n;for(let o of r){let s=i.value.getFieldValue(o);if(!s||!(s instanceof e))return;let a=s.getSelectionParent();if(!a)return;i=a}return i}<span class="fstat-no" title="function not covered" >g</span>etSelectionParent(){let r=this.getField("select")?.value.asObject();if(r)return{kind:"select",value:r};let n=this.getField("include")?.value.asObject();if(n)return{kind:"include",value:n}}<span class="fstat-no" title="function not covered" >g</span>etSubSelectionValue(r){return this.getSelectionParent()?.value.fields[r].value}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){let r=Object.values(this.fields);return r.length==0?2:Math.max(...r.map(i=&gt;i.getPrintWidth()))+2}<span class="fstat-no" title="function not covered" >w</span>rite(r){let n=Object.values(this.fields);if(n.length===0&amp;&amp;this.suggestions.length===0){this.writeEmpty(r);return}this.writeWithContents(r,n)}<span class="fstat-no" title="function not covered" >a</span>sObject(){return this}<span class="fstat-no" title="function not covered" >w</span>riteEmpty(r){let n=new Ce("{}");this.hasError&amp;&amp;n.setColor(r.context.colors.red).underline(),r.write(n)}<span class="fstat-no" title="function not covered" >w</span>riteWithContents(r,n){r.writeLine("{").withIndent(()=&gt;{r.writeJoined(St,[...n,...this.suggestions]).newLine()}),r.write("}"),this.hasError&amp;&amp;r.afterNextNewline(()=&gt;{r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))})}}</span>;var W=class extends Ye{<span class="fstat-no" title="function not covered" >constructor(r){super();this.text=r}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){return this.text.length}<span class="fstat-no" title="function not covered" >w</span>rite(r){let n=new Ce(this.text);this.hasError&amp;&amp;n.underline().setColor(r.context.colors.red),r.write(n)}<span class="fstat-no" title="function not covered" >a</span>sObject(){}}</span>;var Li=class{<span class="fstat-no" title="function not covered" >constructor(t){this.errorMessages=[];this.arguments=t}<span class="fstat-no" title="function not covered" >w</span>rite(t){t.write(this.arguments)}<span class="fstat-no" title="function not covered" >a</span>ddErrorMessage(t){this.errorMessages.push(t)}<span class="fstat-no" title="function not covered" >r</span>enderAllMessages(t){return this.errorMessages.map(r=&gt;r(t)).join(`</span>
`)}};<span class="fstat-no" title="function not covered" >function Ot(e){return new Li(qs(e))}<span class="fstat-no" title="function not covered" >f</span>unction qs(e){let t=new It;for(let[r,n]of Object.entries(e)){let i=new hn(r,js(n));t.addField(i)}return t}<span class="fstat-no" title="function not covered" >f</span>unction js(e){if(typeof e=="string")return new W(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new W(String(e));if(typeof e=="bigint")return new W(`${e}n`);if(e===null)return new W("null");if(e===void 0)return new W("undefined");if(Rt(e))return new W(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return Buffer.isBuffer(e)?new W(`Buffer.alloc(${e.byteLength})`):new W(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let t=on(e)?e.toISOString():"Invalid Date";return new W(`new Date("${t}")`)}return e instanceof Ne?new W(`Prisma.${e._getName()}`):Ct(e)?new W(`prisma.${Ps(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?mp(e):typeof e=="object"?qs(e):new W(Object.prototype.toString.call(e))}<span class="fstat-no" title="function not covered" >f</span>unction mp(e){let t=new At;for(let r of e)t.addItem(js(r));return t}<span class="fstat-no" title="function not covered" >f</span>unction yn(e,t){let r=t==="pretty"?Ms:gn,n=e.renderAllMessages(r),i=new xt(0,{colors:r}).write(e).toString();return{message:n,args:i}}<span class="fstat-no" title="function not covered" >f</span>unction Vs(e){if(e===void 0)return"";let t=Ot(e);return new xt(0,{colors:gn}).write(t).toString()}v</span>ar fp="P2037";<span class="fstat-no" title="function not covered" >function st({error:e,user_facing_error:t},r,n){return t.error_code?new V(gp(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new B(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}<span class="fstat-no" title="function not covered" >f</span>unction gp(e,t){let r=e.message;return(t==="postgresql"||t==="postgres"||t==="mysql")&amp;&amp;e.error_code===fp&amp;&amp;(r+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}var pr="&lt;unknown&gt;";<span class="fstat-no" title="function not covered" >function Bs(e){var t=e.split(`</span>
`);return t.reduce(function(r,n){var i=bp(n)||wp(n)||vp(n)||Sp(n)||Rp(n);return i&amp;&amp;r.push(i),r},[])}var hp=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,yp=/\((\S*)(?::(\d+))(?::(\d+))\)/;<span class="fstat-no" title="function not covered" >function bp(e){var t=hp.exec(e);if(!t)return null;var r=t[2]&amp;&amp;t[2].indexOf("native")===0,n=t[2]&amp;&amp;t[2].indexOf("eval")===0,i=yp.exec(t[2]);return n&amp;&amp;i!=null&amp;&amp;(t[2]=i[1],t[3]=i[2],t[4]=i[3]),{file:r?null:t[2],methodName:t[1]||pr,arguments:r?[t[2]]:[],lineNumber:t[3]?+t[3]:null,column:t[4]?+t[4]:null}}v</span>ar Ep=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;<span class="fstat-no" title="function not covered" >function wp(e){var t=Ep.exec(e);return t?{file:t[2],methodName:t[1]||pr,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}v</span>ar xp=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,Pp=/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i;<span class="fstat-no" title="function not covered" >function vp(e){var t=xp.exec(e);if(!t)return null;var r=t[3]&amp;&amp;t[3].indexOf(" &gt; eval")&gt;-1,n=Pp.exec(t[3]);return r&amp;&amp;n!=null&amp;&amp;(t[3]=n[1],t[4]=n[2],t[5]=null),{file:t[3],methodName:t[1]||pr,arguments:t[2]?t[2].split(","):[],lineNumber:t[4]?+t[4]:null,column:t[5]?+t[5]:null}}v</span>ar Tp=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;<span class="fstat-no" title="function not covered" >function Rp(e){var t=Tp.exec(e);return t?{file:t[3],methodName:t[1]||pr,arguments:[],lineNumber:+t[4],column:t[5]?+t[5]:null}:null}v</span>ar Cp=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;<span class="fstat-no" title="function not covered" >function Sp(e){var t=Cp.exec(e);return t?{file:t[2],methodName:t[1]||pr,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}v</span>ar Ni=class{<span class="fstat-no" title="function not covered" >getLocation(){return null}}</span>,Mi=class{<span class="fstat-no" title="function not covered" >constructor(){this._error=new Error}<span class="fstat-no" title="function not covered" >g</span>etLocation(){let t=this._error.stack;if(!t)return null;let n=Bs(t).find(i=&gt;{if(!i.file)return!1;let o=di(i.file);return o!=="&lt;anonymous&gt;"&amp;&amp;!o.includes("@prisma")&amp;&amp;!o.includes("/packages/client/src/runtime/")&amp;&amp;!o.endsWith("/runtime/binary.js")&amp;&amp;!o.endsWith("/runtime/library.js")&amp;&amp;!o.endsWith("/runtime/edge.js")&amp;&amp;!o.endsWith("/runtime/edge-esm.js")&amp;&amp;!o.startsWith("internal/")&amp;&amp;!i.methodName.includes("new ")&amp;&amp;!i.methodName.includes("getCallSite")&amp;&amp;!i.methodName.includes("Proxy.")&amp;&amp;i.methodName.split(".").length&lt;4});return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}}</span>;<span class="fstat-no" title="function not covered" >function Ze(e){return e==="minimal"?typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new Ni:new Mi}v</span>ar Us={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};<span class="fstat-no" title="function not covered" >function kt(e={}){let t=Ip(e);return Object.entries(t).reduce((n,[i,o])=&gt;(Us[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}<span class="fstat-no" title="function not covered" >f</span>unction Ip(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}<span class="fstat-no" title="function not covered" >f</span>unction bn(e={}){return t=&gt;(typeof e._count=="boolean"&amp;&amp;(t._count=t._count._all),t)}<span class="fstat-no" title="function not covered" >f</span>unction Gs(e,t){let r=bn(e);return t({action:"aggregate",unpacker:r,argsMapper:kt})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Op(e={}){let{select:t,...r}=e;return typeof t=="object"?kt({...r,_count:t}):kt({...r,_count:{_all:!0}})}<span class="fstat-no" title="function not covered" >f</span>unction kp(e={}){return typeof e.select=="object"?t=&gt;bn(e)(t)._count:t=&gt;bn(e)(t)._count._all}<span class="fstat-no" title="function not covered" >f</span>unction Qs(e,t){return t({action:"count",unpacker:kp(e),argsMapper:Op})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Dp(e={}){let t=kt(e);if(Array.isArray(t.by))for(let r of t.by)typeof r=="string"&amp;&amp;(t.select[r]=!0);else typeof t.by=="string"&amp;&amp;(t.select[t.by]=!0);return t}<span class="fstat-no" title="function not covered" >f</span>unction _p(e={}){return t=&gt;(typeof e?._count=="boolean"&amp;&amp;t.forEach(r=&gt;{r._count=r._count._all}),t)}<span class="fstat-no" title="function not covered" >f</span>unction Js(e,t){return t({action:"groupBy",unpacker:_p(e),argsMapper:Dp})(e)}<span class="fstat-no" title="function not covered" >f</span>unction Ws(e,t,r){if(t==="aggregate")return n=&gt;Gs(n,r);if(t==="count")return n=&gt;Qs(n,r);if(t==="groupBy")return n=&gt;Js(n,r)}<span class="fstat-no" title="function not covered" >f</span>unction Hs(e,t){let r=t.fields.filter(i=&gt;!i.relationName),n=Ei(r,i=&gt;i.name);return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new cr(e,o,s.type,s.isList,s.kind==="enum")},...nn(Object.keys(n))})}v</span>ar Ks=<span class="fstat-no" title="function not covered" >e=&gt;Array.isArray(e)?e:e.split("."),</span>$i=<span class="fstat-no" title="function not covered" >(e,t)=&gt;Ks(t).reduce((r,n)=&gt;r&amp;&amp;r[n],e),</span>zs=<span class="fstat-no" title="function not covered" >(e,t,r)=&gt;Ks(t).reduceRight((n,i,o,s)=&gt;Object.assign({},$i(e,s.slice(0,o)),{[i]:n}),r);<span class="fstat-no" title="function not covered" ></span>function Fp(e,t){return e===void 0||t===void 0?[]:[...t,"select",e]}<span class="fstat-no" title="function not covered" >f</span>unction Lp(e,t,r){return t===void 0?e??{}:zs(t,r,e||!0)}<span class="fstat-no" title="function not covered" >f</span>unction qi(e,t,r,n,i,o){let a=e._runtimeDataModel.models[t].fields.reduce((l,u)=&gt;({...l,[u.name]:u}),{});return l=&gt;{let u=Ze(e._errorFormat),c=Fp(n,i),p=Lp(l,o,c),d=r({dataPath:c,callsite:u})(p),f=Np(e,t);return new Proxy(d,{get(g,h){if(!f.includes(h))return g[h];let T=[a[h].type,r,h],S=[c,p];return qi(e,...T,...S)},...nn([...f,...Object.getOwnPropertyNames(d)])})}}<span class="fstat-no" title="function not covered" >f</span>unction Np(e,t){return e._runtimeDataModel.models[t].fields.filter(r=&gt;r.kind==="object").map(r=&gt;r.name)}v</span>ar ra=k(mi());var ta=k(require("fs"));var Ys={keyword:De,entity:De,value:<span class="fstat-no" title="function not covered" >e=&gt;H(rt(e)),</span>punctuation:rt,directive:De,function:De,variable:<span class="fstat-no" title="function not covered" >e=&gt;H(rt(e)),</span>string:<span class="fstat-no" title="function not covered" >e=&gt;H(qe(e)),</span>boolean:ke,number:De,comment:Bt};var Mp=<span class="fstat-no" title="function not covered" >e=&gt;e,</span>En={},$p=0,P={manual:En.Prism<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;En.Prism.manual,</span>disableWorkerMessageHandler:En.Prism<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;En.Prism.disableWorkerMessageHandler,</span>util:{encode:<span class="fstat-no" title="function not covered" >function(e){if(e instanceof he){let t=e;return new he(t.type,P.util.encode(t.content),t.alias)}else return Array.isArray(e)?e.map(P.util.encode):e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/\u00a0/g," ")},</span>type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++$p}),e.__id},clone:function e(t,r){let n,i,o=P.util.type(t);switch(r=r||{},o){case"Object":if(i=P.util.objId(t),r[i])return r[i];n={},r[i]=n;for(let s in t)t.hasOwnProperty(s)&amp;&amp;(n[s]=e(t[s],r));return n;case"Array":return i=P.util.objId(t),r[i]<span class="branch-0 cbranch-no" title="branch not covered" >?r[i]:</span>(n=[],r[i]=n,t.forEach(function(s,a){n[a]=e(s,r)}),n);default:return t}}},languages:{extend:function(e,t){let r=P.util.clone(P.languages[e]);for(let n in t)r[n]=t[n];return r},insertBefore:function(e,t,r,n){n=n||P.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==t)for(let l in r)r.hasOwnProperty(l)&amp;&amp;(o[l]=r[l]);r.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,P.languages.DFS(P.languages,function(a,l){l===s&amp;&amp;a!=e&amp;&amp;(this[a]=o)}),o},DFS:function e(t,r,n,i){i=i||{};let o=P.util.objId;for(let s in t)if(t.hasOwnProperty(s)){r.call(t,s,t[s],n||s);let a=t[s],l=P.util.type(a);l==="Object"&amp;&amp;!i[o(a)]?(i[o(a)]=!0,e(a,r,null,i)):l==="Array"&amp;&amp;!i[o(a)]&amp;&amp;(i[o(a)]=!0,e(a,r,s,i))}}},plugins:{},highlight:<span class="fstat-no" title="function not covered" >function(e,t,r){let n={code:e,grammar:t,language:r};return P.hooks.run("before-tokenize",n),n.tokens=P.tokenize(n.code,n.grammar),P.hooks.run("after-tokenize",n),he.stringify(P.util.encode(n.tokens),n.language)},</span>matchGrammar:<span class="fstat-no" title="function not covered" >function(e,t,r,n,i,o,s){for(let h in r){if(!r.hasOwnProperty(h)||!r[h])continue;if(h==s)return;let O=r[h];O=P.util.type(O)==="Array"?O:[O];for(let T=0;T&lt;O.length;++T){let S=O[T],C=S.inside,E=!!S.lookbehind,me=!!S.greedy,ae=0,jt=S.alias;if(me&amp;&amp;!S.pattern.global){let U=S.pattern.toString().match(/[imuy]*$/)[0];S.pattern=RegExp(S.pattern.source,U+"g")}S=S.pattern||S;for(let U=n,ne=i;U&lt;t.length;ne+=t[U].length,++U){let Ie=t[U];if(t.length&gt;e.length)return;if(Ie instanceof he)continue;if(me&amp;&amp;U!=t.length-1){S.lastIndex=ne;var p=S.exec(e);if(!p)break;var c=p.index+(E?p[1].length:0),d=p.index+p[0].length,a=U,l=ne;for(let _=t.length;a&lt;_&amp;&amp;(l&lt;d||!t[a].type&amp;&amp;!t[a-1].greedy);++a)l+=t[a].length,c&gt;=l&amp;&amp;(++U,ne=l);if(t[U]instanceof he)continue;u=a-U,Ie=e.slice(ne,l),p.index-=ne}else{S.lastIndex=0;var p=S.exec(Ie),u=1}if(!p){if(o)break;continue}E&amp;&amp;(ae=p[1]?p[1].length:0);var c=p.index+ae,p=p[0].slice(ae),d=c+p.length,f=Ie.slice(0,c),g=Ie.slice(d);let z=[U,u];f&amp;&amp;(++U,ne+=f.length,z.push(f));let dt=new he(h,C?P.tokenize(p,C):p,jt,p,me);if(z.push(dt),g&amp;&amp;z.push(g),Array.prototype.splice.apply(t,z),u!=1&amp;&amp;P.matchGrammar(e,t,r,U,ne,!0,h),o)break}}}},</span>tokenize:<span class="fstat-no" title="function not covered" >function(e,t){let r=[e],n=t.rest;if(n){for(let i in n)t[i]=n[i];delete t.rest}return P.matchGrammar(e,r,t,0,0,!1),r},</span>hooks:{all:{},add:<span class="fstat-no" title="function not covered" >function(e,t){let r=P.hooks.all;r[e]=r[e]||[],r[e].push(t)},</span>run:<span class="fstat-no" title="function not covered" >function(e,t){let r=P.hooks.all[e];if(!(!r||!r.length))for(var n=0,i;i=r[n++];)i(t)}}</span>,Token:he};P.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};P.languages.javascript=P.languages.extend("clike",{"class-name":[P.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|&lt;&lt;?=?|&gt;&gt;?&gt;?=?|=(?:==?|&gt;)?|&amp;[&amp;=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});P.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;P.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=&gt;))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:P.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=&gt;)/i,inside:P.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=&gt;)/,lookbehind:!0,inside:P.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:P.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});P.languages.markup<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;P.languages.markup.tag.addInlined("script","javascript");</span>P.languages.js=P.languages.javascript;P.languages.typescript=P.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});P.languages.ts=P.languages.typescript;<span class="fstat-no" title="function not covered" >function he(e,t,r,n,i){this.type=e,this.content=t,this.alias=r,this.length=(n||"").length|0,this.greedy=!!i}h</span>e.stringify=<span class="fstat-no" title="function not covered" >function(e,t){return typeof e=="string"?e:Array.isArray(e)?e.map(function(r){return he.stringify(r,t)}).join(""):qp(e.type)(e.content)};<span class="fstat-no" title="function not covered" >f</span>unction qp(e){return Ys[e]||Mp}<span class="fstat-no" title="function not covered" >f</span>unction Zs(e){return jp(e,P.languages.javascript)}<span class="fstat-no" title="function not covered" >f</span>unction jp(e,t){return P.tokenize(e,t).map(n=&gt;he.stringify(n)).join("")}v</span>ar Xs=k(ss());<span class="fstat-no" title="function not covered" >function ea(e){return(0,Xs.default)(e)}v</span>ar wn=class e{static <span class="fstat-no" title="function not covered" >read(t){let r;try{r=ta.default.readFileSync(t,"utf-8")}catch{return null}return e.fromContent(r)}s</span>tatic <span class="fstat-no" title="function not covered" >fromContent(t){let r=t.split(/\r?\n/);return new e(1,r)}<span class="fstat-no" title="function not covered" >c</span>onstructor(t,r){this.firstLineNumber=t,this.lines=r}<span class="fstat-no" title="function not covered" >g</span>et lastLineNumber(){return this.firstLineNumber+this.lines.length-1}<span class="fstat-no" title="function not covered" >m</span>apLineAt(t,r){if(t&lt;this.firstLineNumber||t&gt;this.lines.length+this.firstLineNumber)return this;let n=t-this.firstLineNumber,i=[...this.lines];return i[n]=r(i[n]),new e(this.firstLineNumber,i)}<span class="fstat-no" title="function not covered" >m</span>apLines(t){return new e(this.firstLineNumber,this.lines.map((r,n)=&gt;t(r,this.firstLineNumber+n)))}<span class="fstat-no" title="function not covered" >l</span>ineAt(t){return this.lines[t-this.firstLineNumber]}<span class="fstat-no" title="function not covered" >p</span>rependSymbolAt(t,r){return this.mapLines((n,i)=&gt;i===t?`${r} ${n}`:`  ${n}`)}<span class="fstat-no" title="function not covered" >s</span>lice(t,r){let n=this.lines.slice(t-1,r).join(`</span>
<span class="cstat-no" title="statement not covered" >`);return new e(t,ea(n).split(`</span>
`))}<span class="fstat-no" title="function not covered" >highlight(){let t=Zs(this.toString());return new e(this.firstLineNumber,t.split(`</span>
`))}<span class="fstat-no" title="function not covered" >toString(){return this.lines.join(`</span>
`)}};var Vp={red:ce,gray:Bt,dim:Oe,bold:H,underline:X,highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;e.highlight()}</span>,Bp={red:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>gray:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>dim:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>bold:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>underline:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;e}</span>;<span class="fstat-no" title="function not covered" >function Up({message:e,originalMethod:t,isPanic:r,callArguments:n}){return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}<span class="fstat-no" title="function not covered" >f</span>unction Gp({callsite:e,message:t,originalMethod:r,isPanic:n,callArguments:i},o){let s=Up({message:t,originalMethod:r,isPanic:n,callArguments:i});if(!e||typeof window&lt;"u"||process.env.NODE_ENV==="production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=wn.read(a.fileName)?.slice(l,a.lineNumber),c=u?.lineAt(a.lineNumber);if(u&amp;&amp;c){let p=Jp(c),d=Qp(c);if(!d)return s;s.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,g=&gt;g.slice(0,d.openingBraceIndex))),u=o.highlightSource(u);let f=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((g,h)=&gt;o.gray(String(h).padStart(f))+" "+g).mapLines(g=&gt;o.dim(g)).prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let g=p+f+1;g+=2,s.callArguments=(0,ra.default)(i,g).slice(g)}}return s}<span class="fstat-no" title="function not covered" >f</span>unction Qp(e){let t=Object.keys(Je.ModelAction).join("|"),n=new RegExp(String.raw`\.(${t})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}<span class="fstat-no" title="function not covered" >f</span>unction Jp(e){let t=0;for(let r=0;r&lt;e.length;r++){if(e.charAt(r)!==" ")return t;t++}return t}<span class="fstat-no" title="function not covered" >f</span>unction Wp({functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=t?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&amp;&amp;a.push(s.underline(Hp(t))),i){a.push("");let u=[i.toString()];o&amp;&amp;(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&amp;&amp;a.push("")}else a.push(""),o&amp;&amp;a.push(o),a.push("");return a.push(r),a.join(`</span>
`)}<span class="fstat-no" title="function not covered" >function Hp(e){let t=[e.fileName];return e.lineNumber&amp;&amp;t.push(String(e.lineNumber)),e.columnNumber&amp;&amp;t.push(String(e.columnNumber)),t.join(":")}<span class="fstat-no" title="function not covered" >f</span>unction Dt(e){let t=e.showColors?Vp:Bp,r;return r=Gp(e,t),Wp(r,t)}<span class="fstat-no" title="function not covered" >f</span>unction na(e,t,r,n){return e===Je.ModelAction.findFirstOrThrow||e===Je.ModelAction.findUniqueOrThrow?Kp(t,r,n):n}<span class="fstat-no" title="function not covered" >f</span>unction Kp(e,t,r){return async n=&gt;{if("rejectOnNotFound"in n.args){let o=Dt({originalMethod:n.clientMethod,callsite:n.callsite,message:"'rejectOnNotFound' option is not supported"});throw new J(o,{clientVersion:t})}return await r(n).catch(o=&gt;{throw o instanceof V&amp;&amp;o.code==="P2025"?new Le(`No ${e} found`,t):o})}}f</span>unction Se(e){return e.replace(/^./,t=&gt;t.toLowerCase())}var zp=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],Yp=["aggregate","count","groupBy"];<span class="fstat-no" title="function not covered" >function ji(e,t){let r=e._extensions.getAllModelExtensions(t)??{},n=[Zp(e,t),ed(e,t),lr(r),re("name",()=&gt;t),re("$name",()=&gt;t),re("$parent",()=&gt;e._appliedParent)];return ve({},n)}<span class="fstat-no" title="function not covered" >f</span>unction Zp(e,t){let r=Se(t),n=Object.keys(Je.ModelAction).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=l=&gt;e._request(l);s=na(o,t,e._clientVersion,s);let a=l=&gt;u=&gt;{let c=Ze(e._errorFormat);return e._createPrismaPromise(p=&gt;{let d={args:u,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:p,callsite:c};return s({...d,...l})})};return zp.includes(o)?qi(e,t,a):Xp(i)?Ws(e,i,a):a({})}}}<span class="fstat-no" title="function not covered" >f</span>unction Xp(e){return Yp.includes(e)}<span class="fstat-no" title="function not covered" >f</span>unction ed(e,t){return it(re("fields",()=&gt;{let r=e._runtimeDataModel.models[t];return Hs(t,r)}))}<span class="fstat-no" title="function not covered" >f</span>unction ia(e){return e.replace(/^./,t=&gt;t.toUpperCase())}v</span>ar Vi=Symbol();function dr(e){let t=[td(e),re(Vi,()=&gt;e),re("$parent",()=&gt;e._appliedParent)],r=e._extensions.getAllClientExtensions();return r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;t.push(lr(r)),</span>ve(e,t)}function td(e){let t=Object.keys(e._runtimeDataModel.models),r=t.map(Se),n=[...new Set(t.concat(r))];return it({getKeys(){return n},<span class="fstat-no" title="function not covered" >getPropertyValue(i){let o=ia(i);if(e._runtimeDataModel.models[o]!==void 0)return ji(e,o);if(e._runtimeDataModel.models[i]!==void 0)return ji(e,i)},<span class="fstat-no" title="function not covered" ></span>getPropertyDescriptor(i){if(!r.includes(i))return{enumerable:!1}}}</span>)}<span class="fstat-no" title="function not covered" >function oa(e){return e[Vi]?e[Vi]:e}<span class="fstat-no" title="function not covered" >f</span>unction sa(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let r=e.client.__AccelerateEngine;this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}let t=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return dr(t)}<span class="fstat-no" title="function not covered" >f</span>unction aa({result:e,modelName:t,select:r,omit:n,extensions:i}){let o=i.getAllComputedFields(t);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(c=&gt;n[c]);u.length&gt;0&amp;&amp;a.push(Et(u))}else if(r){if(!r[l.name])continue;let u=l.needs.filter(c=&gt;!r[c]);u.length&gt;0&amp;&amp;a.push(Et(u))}rd(e,l.needs)&amp;&amp;s.push(nd(l,ve(e,s)))}return s.length&gt;0||a.length&gt;0?ve(e,[...s,...a]):e}<span class="fstat-no" title="function not covered" >f</span>unction rd(e,t){return t.every(r=&gt;bi(e,r))}<span class="fstat-no" title="function not covered" >f</span>unction nd(e,t){return it(re(e.name,()=&gt;e.compute(t)))}<span class="fstat-no" title="function not covered" >f</span>unction xn({visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){if(Array.isArray(t)){for(let s=0;s&lt;t.length;s++)t[s]=xn({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});return t}let o=e(t,i,r)??t;return r.include&amp;&amp;la({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&amp;&amp;la({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}<span class="fstat-no" title="function not covered" >f</span>unction la({includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||t[o]==null||we(s))continue;let l=n.models[r].fields.find(c=&gt;c.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};t[o]=xn({visitor:i,result:t[o],args:u,modelName:l.type,runtimeDataModel:n})}}<span class="fstat-no" title="function not covered" >f</span>unction ua({result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:xn({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:(a,l,u)=&gt;{let c=Se(l);return aa({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}})}<span class="fstat-no" title="function not covered" >f</span>unction ca(e){if(e instanceof ie)return id(e);if(Array.isArray(e)){let r=[e[0]];for(let n=1;n&lt;e.length;n++)r[n]=mr(e[n]);return r}let t={};for(let r in e)t[r]=mr(e[r]);return t}<span class="fstat-no" title="function not covered" >f</span>unction id(e){return new ie(e.strings,e.values)}<span class="fstat-no" title="function not covered" >f</span>unction mr(e){if(typeof e!="object"||e==null||e instanceof Ne||Ct(e))return e;if(Rt(e))return new Re(e.toFixed());if(Pt(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let t=e.length,r;for(r=Array(t);t--;)r[t]=mr(e[t]);return r}if(typeof e=="object"){let t={};for(let r in e)r==="__proto__"?Object.defineProperty(t,r,{value:mr(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=mr(e[r]);return t}Fe(e,"Unknown value")}<span class="fstat-no" title="function not covered" >f</span>unction da(e,t,r,n=0){return e._createPrismaPromise(i=&gt;{let o=t.customDataProxyFetch;return"transaction"in t&amp;&amp;i!==void 0&amp;&amp;(t.transaction?.kind==="batch"&amp;&amp;t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:ca(t.args??{}),__internalParams:t,query:(s,a=t)=&gt;{let l=a.customDataProxyFetch;return a.customDataProxyFetch=ha(o,l),a.args=s,da(e,a,r,n+1)}})})}<span class="fstat-no" title="function not covered" >f</span>unction ma(e,t){let{jsModelName:r,action:n,clientMethod:i}=t,o=r?n:i;if(e._extensions.isEmpty())return e._executeRequest(t);let s=e._extensions.getAllQueryCallbacks(r??"$none",o);return da(e,t,s)}f</span>unction fa(e){return t=&gt;{let r={requests:t},n=t[0].extensions.getAllBatchQueryCallbacks();return n.length?ga(r,n,0,e):e(r)}}<span class="fstat-no" title="function not covered" >function ga(e,t,r,n){if(r===t.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return t[r]({args:{queries:e.requests.map(s=&gt;({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=ha(i,l),ga(a,t,r+1,n)}})}v</span>ar pa=<span class="fstat-no" title="function not covered" >e=&gt;e;<span class="fstat-no" title="function not covered" ></span>function ha(e=pa,t=pa){return r=&gt;e(t(r))}<span class="fstat-no" title="function not covered" >f</span>unction ba(e,t,r){let n=Se(r);return!t.result||!(t.result.$allModels||t.result[n])?e:od({...e,...ya(t.name,e,t.result.$allModels),...ya(t.name,e,t.result[n])})}<span class="fstat-no" title="function not covered" >f</span>unction od(e){let t=new Pe,r=(n,i)=&gt;t.getOrCreate(n,()=&gt;i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=&gt;r(o,i)):[n]));return yt(e,n=&gt;({...n,needs:r(n.name,new Set)}))}<span class="fstat-no" title="function not covered" >f</span>unction ya(e,t,r){return r?yt(r,({needs:n,compute:i},o)=&gt;({name:o,needs:n?Object.keys(n).filter(s=&gt;n[s]):[],compute:sd(t,o,i)})):{}}<span class="fstat-no" title="function not covered" >f</span>unction sd(e,t,r){let n=e?.[t]?.compute;return n?i=&gt;r({...i,[t]:n(i)}):r}<span class="fstat-no" title="function not covered" >f</span>unction Ea(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(e[n.name])for(let i of n.needs)r[i]=!0;return r}<span class="fstat-no" title="function not covered" >f</span>unction wa(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(!e[n.name])for(let i of n.needs)delete r[i];return r}v</span>ar Pn=class{<span class="fstat-no" title="function not covered" >constructor(t,r){this.extension=t;this.previous=r;this.computedFieldsCache=new Pe;this.modelExtensionsCache=new Pe;this.queryCallbacksCache=new Pe;this.clientExtensions=er(()=&gt;this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());this.batchCallbacks=er(()=&gt;{let t=this.previous?.getAllBatchQueryCallbacks()??[],r=this.extension.query?.$__internalBatch;return r?t.concat(r):t})}<span class="fstat-no" title="function not covered" >g</span>etAllComputedFields(t){return this.computedFieldsCache.getOrCreate(t,()=&gt;ba(this.previous?.getAllComputedFields(t),this.extension,t))}<span class="fstat-no" title="function not covered" >g</span>etAllClientExtensions(){return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" >g</span>etAllModelExtensions(t){return this.modelExtensionsCache.getOrCreate(t,()=&gt;{let r=Se(t);return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}})}<span class="fstat-no" title="function not covered" >g</span>etAllQueryCallbacks(t,r){return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,()=&gt;{let n=this.previous?.getAllQueryCallbacks(t,r)??[],i=[],o=this.extension.query;return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&amp;&amp;(o[t][r]!==void 0&amp;&amp;i.push(o[t][r]),o[t].$allOperations!==void 0&amp;&amp;i.push(o[t].$allOperations)),t!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[r]!==void 0&amp;&amp;i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[r]!==void 0&amp;&amp;i.push(o[r]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))})}<span class="fstat-no" title="function not covered" >g</span>etAllBatchQueryCallbacks(){return this.batchCallbacks.get()}}</span>,vn=class e{constructor(t){this.head=t}static empty(){return new e}static <span class="fstat-no" title="function not covered" >single(t){return new e(new Pn(t))}<span class="fstat-no" title="function not covered" >i</span>sEmpty(){return this.head===void 0}<span class="fstat-no" title="function not covered" >a</span>ppend(t){return new e(new Pn(t,this.head))}<span class="fstat-no" title="function not covered" >g</span>etAllComputedFields(t){return this.head?.getAllComputedFields(t)}g</span>etAllClientExtensions(){return this.head<span class="branch-0 cbranch-no" title="branch not covered" >?.getAllClientExtensions(</span>)}<span class="fstat-no" title="function not covered" >getAllModelExtensions(t){return this.head?.getAllModelExtensions(t)}<span class="fstat-no" title="function not covered" >g</span>etAllQueryCallbacks(t,r){return this.head?.getAllQueryCallbacks(t,r)??[]}<span class="fstat-no" title="function not covered" >g</span>etAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}}</span>;var xa=L("prisma:client"),Pa={Vercel:"vercel","Netlify CI":"netlify"};function va({postinstall:e,ciName:t,clientVersion:r}){if(xa("checkPlatformCaching:postinstall",e),xa("checkPlatformCaching:ciName",t),e===!0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;t<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;t in Pa)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let n=`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span>
<span class="cstat-no" title="statement not covered" ></span>
Learn how: https://pris.ly/d/${Pa[t]}-build`;throw console.error(n),new R(n,r)}}function Ta(e,t){return e?e.datasources<span class="branch-0 cbranch-no" title="branch not covered" >?e.datasources:</span>e.datasourceUrl<span class="branch-0 cbranch-no" title="branch not covered" >?{[t[0]]:{url:e.datasourceUrl}}:</span>{}<span class="branch-0 cbranch-no" title="branch not covered" >:{}}</span>var ad="Cloudflare-Workers",ld="node";<span class="fstat-no" title="function not covered" >function Ra(){return typeof Netlify=="object"?"netlify":typeof EdgeRuntime=="string"?"edge-light":globalThis.navigator?.userAgent===ad?"workerd":globalThis.Deno?"deno":globalThis.__lagon__?"lagon":globalThis.process?.release?.name===ld?"node":globalThis.Bun?"bun":globalThis.fastly?"fastly":"unknown"}v</span>ar ud={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};<span class="fstat-no" title="function not covered" >function Tn(){let e=Ra();return{id:e,prettyName:ud[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}v</span>ar Oa=k(require("fs")),fr=k(require("path"));<span class="fstat-no" title="function not covered" >function Rn(e){let{runtimeBinaryTarget:t}=e;return`Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:</span>
<span class="cstat-no" title="statement not covered" ></span>
${cd(e)}`}<span class="fstat-no" title="function not covered" >function cd(e){let{generator:t,generatorBinaryTargets:r,runtimeBinaryTarget:n}=e,i={fromEnvVar:null,value:n},o=[...r,i];return gi({...t,binaryTargets:o})}<span class="fstat-no" title="function not covered" >f</span>unction Xe(e){let{runtimeBinaryTarget:t}=e;return`Prisma Client could not locate the Query Engine for runtime "${t}".`}<span class="fstat-no" title="function not covered" >f</span>unction et(e){let{searchedLocations:t}=e;return`The following locations have been searched:</span>
<span class="cstat-no" title="statement not covered" >${[...new Set(t)].map(i=&gt;`  ${i}`).join(`</span>
`)}`}<span class="fstat-no" title="function not covered" >function Ca(e){let{runtimeBinaryTarget:t}=e;return`${Xe(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".</span>
<span class="cstat-no" title="statement not covered" >${Rn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
${et(e)}`}<span class="fstat-no" title="function not covered" >function Cn(e){return`We would appreciate if you could take the time to share some information with us.</span>
Please help us by answering a few questions: https://pris.ly/${e}`}<span class="fstat-no" title="function not covered" >function Sn(e){let{errorStack:t}=e;return t?.match(/\/\.next|\/next@|\/next\//)?`</span>
<span class="cstat-no" title="statement not covered" ></span>
We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}<span class="fstat-no" title="function not covered" >function Sa(e){let{queryEngineName:t}=e;return`${Xe(e)}${Sn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.</span>
<span class="cstat-no" title="statement not covered" >Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${Cn("engine-not-found-bundler-investigation")}</span>
<span class="cstat-no" title="statement not covered" ></span>
${et(e)}`}<span class="fstat-no" title="function not covered" >function Aa(e){let{runtimeBinaryTarget:t,generatorBinaryTargets:r}=e,n=r.find(i=&gt;i.native);return`${Xe(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${t}".</span>
<span class="cstat-no" title="statement not covered" >${Rn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
${et(e)}`}<span class="fstat-no" title="function not covered" >function Ia(e){let{queryEngineName:t}=e;return`${Xe(e)}${Sn(e)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is likely caused by tooling that has not copied "${t}" to the deployment folder.</span>
<span class="cstat-no" title="statement not covered" >Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${Cn("engine-not-found-tooling-investigation")}</span>
<span class="cstat-no" title="statement not covered" ></span>
${et(e)}`}var pd=L("prisma:client:engines:resolveEnginePath"),dd=<span class="fstat-no" title="function not covered" >()=&gt;new RegExp("runtime[\\\\/]library\\.m?js$");</span>async function ka(e,t){let r={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??t.prismaPath;if(r!==void 0)<span class="branch-0 cbranch-no" title="branch not covered" >return r;l</span>et{enginePath:n,searchedLocations:i}=await md(e,t);if(pd("enginePath",n),n!==void 0&amp;&amp;e==="binary"<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;ai(n),</span>n!==void 0)return t.prismaPath=n<span class="branch-0 cbranch-no" title="branch not covered" >;let o=await nt(),s=t.generator?.binaryTargets<span class="branch-0 cbranch-no" title="branch not covered" >?</span>?[],</span>a=s.some(d=&gt;d.native),l=!s.some(d=&gt;d.value===o),u=__filename.match(dd())===null,c={searchedLocations:i,generatorBinaryTargets:s,generator:t.generator,runtimeBinaryTarget:o,queryEngineName:Da(e,o),expectedLocation:fr.default.relative(process.cwd(),t.dirname),errorStack:new Error().stack},p;throw a<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;l<span class="branch-0 cbranch-no" title="branch not covered" >?</span>p=Aa(c)<span class="branch-0 cbranch-no" title="branch not covered" >:</span>l?p=Ca(c):u?p=Sa(c):p=Ia(c),</span>new R(p,t.clientVersion)}async function md(engineType,config){let binaryTarget=await nt(),searchedLocations=[],dirname=eval("__dirname"),searchLocations=[config.dirname,fr.default.resolve(dirname,".."),config.generator?.output?.value<span class="branch-0 cbranch-no" title="branch not covered" >??dirname,</span>fr.default.resolve(dirname,"../../../.prisma/client"),"/tmp/prisma-engines",config.cwd];__filename.includes("resolveEnginePath")<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;searchLocations.push(Ho());</span>for(let e of searchLocations){let t=Da(engineType,binaryTarget),r=fr.default.join(e,t);if(searchedLocations.push(e),Oa.default.existsSync(r))return{enginePath:r,searchedLocations}<span class="branch-0 cbranch-no" title="branch not covered" >}return{enginePath:void 0,searchedLocations}}f</span>unction Da(e,t){return e==="library"?$r(t,"fs")<span class="branch-0 cbranch-no" title="branch not covered" >:`query-engine-${t}${t==="windows"?".exe":""}`}</span>var Bi=k(yi());<span class="fstat-no" title="function not covered" >function _a(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,t=&gt;`${t[0]}5`):""}<span class="fstat-no" title="function not covered" >f</span>unction Fa(e){return e.split(`</span>
<span class="cstat-no" title="statement not covered" >`).map(t=&gt;t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).join(`</span>
`)}var La=k(ms());<span class="fstat-no" title="function not covered" >function Na({title:e,user:t="prisma",repo:r="prisma",template:n="bug_report.yml",body:i}){return(0,La.default)({user:t,repo:r,template:n,title:e,body:i})}<span class="fstat-no" title="function not covered" >f</span>unction Ma({version:e,binaryTarget:t,title:r,description:n,engineVersion:i,database:o,query:s}){let a=To(6e3-(s?.length??0)),l=Fa((0,Bi.default)(a)),u=n?`# Description</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${n}</span>
<span class="cstat-no" title="statement not covered" >\`\`\``:"",c=(0,Bi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span>
<span class="cstat-no" title="statement not covered" >## Versions</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >| Name            | Version            |</span>
<span class="cstat-no" title="statement not covered" >|-----------------|--------------------|</span>
<span class="cstat-no" title="statement not covered" >| Node            | ${process.version?.padEnd(19)}| </span>
<span class="cstat-no" title="statement not covered" >| OS              | ${t?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Prisma Client   | ${e?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Query Engine    | ${i?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Database        | ${o?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${u}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Logs</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${l}</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Client Snippet</span>
<span class="cstat-no" title="statement not covered" >\`\`\`ts</span>
<span class="cstat-no" title="statement not covered" >// PLEASE FILL YOUR CODE SNIPPET HERE</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Schema</span>
<span class="cstat-no" title="statement not covered" >\`\`\`prisma</span>
<span class="cstat-no" title="statement not covered" >// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >## Prisma Engine Query</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >${s?_a(s):""}</span>
<span class="cstat-no" title="statement not covered" >\`\`\`</span>
<span class="cstat-no" title="statement not covered" >`),p=Na({title:r,body:c});return`${r}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${X(p)}</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >If you want the Prisma team to look into it, please open the link above \u{1F64F}</span>
<span class="cstat-no" title="statement not covered" >To increase the chance of success, please post your schema and a snippet of</span>
<span class="cstat-no" title="statement not covered" >how you used Prisma Client in the issue. </span>
`}function _t({inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=t[o]<span class="branch-0 cbranch-no" title="branch not covered" >?.url;</span>if(o===void 0<span class="branch-0 cbranch-no" title="branch not covered" >?i=void 0:</span>a<span class="branch-0 cbranch-no" title="branch not covered" >?i=a:</span>s?.value<span class="branch-0 cbranch-no" title="branch not covered" >?i=s.value:</span>s?.fromEnvVar&amp;&amp;(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" >throw new R(`error: Environment variable not found: ${s.fromEnvVar}.`,n);i</span>f(i===void 0)<span class="branch-0 cbranch-no" title="branch not covered" >throw new R("error: Missing URL environment variable, value, or override.",n);r</span>eturn i}var An=class extends Error{<span class="fstat-no" title="function not covered" >constructor(t,r){super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return this.name}}</span>;var se=class extends An{<span class="fstat-no" title="function not covered" >constructor(t,r){super(t,r),this.isRetryable=r.isRetryable??!0}}</span>;<span class="fstat-no" title="function not covered" >function A(e,t){return{...e,isRetryable:t}}v</span>ar Ft=class extends se{<span class="fstat-no" title="function not covered" >constructor(r){super("This request must be retried",A(r,!0));this.name="ForcedRetryError";this.code="P5001"}}</span>;w(Ft,"ForcedRetryError");var at=class extends se{<span class="fstat-no" title="function not covered" >constructor(r,n){super(r,A(n,!1));this.name="InvalidDatasourceError";this.code="P6001"}}</span>;w(at,"InvalidDatasourceError");var lt=class extends se{<span class="fstat-no" title="function not covered" >constructor(r,n){super(r,A(n,!1));this.name="NotImplementedYetError";this.code="P5004"}}</span>;w(lt,"NotImplementedYetError");var q=class extends se{<span class="fstat-no" title="function not covered" >constructor(t,r){super(t,r),this.response=r.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}}</span>;var ut=class extends q{<span class="fstat-no" title="function not covered" >constructor(r){super("Schema needs to be uploaded",A(r,!0));this.name="SchemaMissingError";this.code="P5005"}}</span>;w(ut,"SchemaMissingError");var Ui="This request could not be understood by the server",gr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n,i){super(n||Ui,A(r,!1));this.name="BadRequestError";this.code="P5000";i&amp;&amp;(this.code=i)}}</span>;w(gr,"BadRequestError");var hr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n){super("Engine not started: healthcheck timeout",A(r,!0));this.name="HealthcheckTimeoutError";this.code="P5013";this.logs=n}}</span>;w(hr,"HealthcheckTimeoutError");var yr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n,i){super(n,A(r,!0));this.name="EngineStartupError";this.code="P5014";this.logs=i}}</span>;w(yr,"EngineStartupError");var br=class extends q{<span class="fstat-no" title="function not covered" >constructor(r){super("Engine version is not supported",A(r,!1));this.name="EngineVersionNotSupportedError";this.code="P5012"}}</span>;w(br,"EngineVersionNotSupportedError");var Gi="Request timed out",Er=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=Gi){super(n,A(r,!1));this.name="GatewayTimeoutError";this.code="P5009"}}</span>;w(Er,"GatewayTimeoutError");var fd="Interactive transaction error",wr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=fd){super(n,A(r,!1));this.name="InteractiveTransactionError";this.code="P5015"}}</span>;w(wr,"InteractiveTransactionError");var gd="Request parameters are invalid",xr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=gd){super(n,A(r,!1));this.name="InvalidRequestError";this.code="P5011"}}</span>;w(xr,"InvalidRequestError");var Qi="Requested resource does not exist",Pr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=Qi){super(n,A(r,!1));this.name="NotFoundError";this.code="P5003"}}</span>;w(Pr,"NotFoundError");var Ji="Unknown server error",Lt=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n,i){super(n||Ji,A(r,!0));this.name="ServerError";this.code="P5006";this.logs=i}}</span>;w(Lt,"ServerError");var Wi="Unauthorized, check your connection string",vr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=Wi){super(n,A(r,!1));this.name="UnauthorizedError";this.code="P5007"}}</span>;w(vr,"UnauthorizedError");var Hi="Usage exceeded, retry again later",Tr=class extends q{<span class="fstat-no" title="function not covered" >constructor(r,n=Hi){super(n,A(r,!0));this.name="UsageExceededError";this.code="P5008"}}</span>;w(Tr,"UsageExceededError");<span class="fstat-no" title="function not covered" >async function hd(e){let t;try{t=await e.text()}catch{return{type:"EmptyError"}}try{let r=JSON.parse(t);if(typeof r=="string")switch(r){case"InternalDataProxyError":return{type:"DataProxyError",body:r};default:return{type:"UnknownTextError",body:r}}if(typeof r=="object"&amp;&amp;r!==null){if("is_panic"in r&amp;&amp;"message"in r&amp;&amp;"error_code"in r)return{type:"QueryEngineError",body:r};if("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=Object.values(r)[0].reason;return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}}return{type:"UnknownJsonError",body:r}}catch{return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}}<span class="fstat-no" title="function not covered" >a</span>sync function Rr(e,t){if(e.ok)return;let r={clientVersion:t,response:e},n=await hd(e);if(n.type==="QueryEngineError")throw new V(n.body.message,{code:n.body.error_code,clientVersion:t});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new Lt(r,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new ut(r);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new br(r);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new yr(r,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new R(i,t,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new hr(r,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new wr(r,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new xr(r,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new vr(r,Nt(Wi,n));if(e.status===404)return new Pr(r,Nt(Qi,n));if(e.status===429)throw new Tr(r,Nt(Hi,n));if(e.status===504)throw new Er(r,Nt(Gi,n));if(e.status&gt;=500)throw new Lt(r,Nt(Ji,n));if(e.status&gt;=400)throw new gr(r,Nt(Ui,n))}<span class="fstat-no" title="function not covered" >f</span>unction Nt(e,t){return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}<span class="fstat-no" title="function not covered" >f</span>unction $a(e){let t=Math.pow(2,e)*50,r=Math.ceil(Math.random()*t)-Math.ceil(t/2),n=t+r;return new Promise(i=&gt;setTimeout(()=&gt;i(n),n))}v</span>ar $e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";<span class="fstat-no" title="function not covered" >function qa(e){let t=new TextEncoder().encode(e),r="",n=t.byteLength,i=n%3,o=n-i,s,a,l,u,c;for(let p=0;p&lt;o;p=p+3)c=t[p]&lt;&lt;16|t[p+1]&lt;&lt;8|t[p+2],s=(c&amp;16515072)&gt;&gt;18,a=(c&amp;258048)&gt;&gt;12,l=(c&amp;4032)&gt;&gt;6,u=c&amp;63,r+=$e[s]+$e[a]+$e[l]+$e[u];return i==1?(c=t[o],s=(c&amp;252)&gt;&gt;2,a=(c&amp;3)&lt;&lt;4,r+=$e[s]+$e[a]+"=="):i==2&amp;&amp;(c=t[o]&lt;&lt;8|t[o+1],s=(c&amp;64512)&gt;&gt;10,a=(c&amp;1008)&gt;&gt;4,l=(c&amp;15)&lt;&lt;2,r+=$e[s]+$e[a]+$e[l]+"="),r}<span class="fstat-no" title="function not covered" >f</span>unction ja(e){if(!!e.generator?.previewFeatures.some(r=&gt;r.toLowerCase().includes("metrics")))throw new R("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}<span class="fstat-no" title="function not covered" >f</span>unction yd(e){return e[0]*1e3+e[1]/1e6}<span class="fstat-no" title="function not covered" >f</span>unction Va(e){return new Date(yd(e))}v</span>ar Ba={"@prisma/debug":"workspace:*","@prisma/engines-version":"5.21.1-1.bf0e5e8a04cada8225617067eaa03d041e2bba36","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var Cr=class extends se{<span class="fstat-no" title="function not covered" >constructor(r,n){super(`Cannot fetch data from service:</span>
${r}`,A(n,!0));this.name="RequestError";this.code="P5010"}};w(Cr,"RequestError");<span class="fstat-no" title="function not covered" >async function ct(e,t,r=n=&gt;n){let n=t.clientVersion;try{return typeof fetch=="function"?await r(fetch)(e,t):await r(Ki)(e,t)}catch(i){let o=i.message??"Unknown error";throw new Cr(o,{clientVersion:n})}}<span class="fstat-no" title="function not covered" >f</span>unction Ed(e){return{...e.headers,"Content-Type":"application/json"}}<span class="fstat-no" title="function not covered" >f</span>unction wd(e){return{method:e.method,headers:Ed(e)}}<span class="fstat-no" title="function not covered" >f</span>unction xd(e,t){return{text:()=&gt;Promise.resolve(Buffer.concat(e).toString()),json:()=&gt;Promise.resolve().then(()=&gt;JSON.parse(Buffer.concat(e).toString())),ok:t.statusCode&gt;=200&amp;&amp;t.statusCode&lt;=299,status:t.statusCode,url:t.url,headers:new zi(t.headers)}}<span class="fstat-no" title="function not covered" >a</span>sync function Ki(e,t={}){let r=Pd("https"),n=wd(t),i=[],{origin:o}=new URL(e);return new Promise((s,a)=&gt;{let l=r.request(e,n,u=&gt;{let{statusCode:c,headers:{location:p}}=u;c&gt;=301&amp;&amp;c&lt;=399&amp;&amp;p&amp;&amp;(p.startsWith("http")===!1?s(Ki(`${o}${p}`,t)):s(Ki(p,t))),u.on("data",d=&gt;i.push(d)),u.on("end",()=&gt;s(xd(i,u))),u.on("error",a)});l.on("error",a),l.end(t.body??"")})}v</span>ar Pd=typeof require&lt;"u"?require<span class="branch-0 cbranch-no" title="branch not covered" >:<span class="fstat-no" title="function not covered" >()=&gt;{},</span></span>zi=class{<span class="fstat-no" title="function not covered" >constructor(t={}){this.headers=new Map;for(let[r,n]of Object.entries(t))if(typeof n=="string")this.headers.set(r,n);else if(Array.isArray(n))for(let i of n)this.headers.set(r,i)}<span class="fstat-no" title="function not covered" >a</span>ppend(t,r){this.headers.set(t,r)}<span class="fstat-no" title="function not covered" >d</span>elete(t){this.headers.delete(t)}<span class="fstat-no" title="function not covered" >g</span>et(t){return this.headers.get(t)??null}<span class="fstat-no" title="function not covered" >h</span>as(t){return this.headers.has(t)}<span class="fstat-no" title="function not covered" >s</span>et(t,r){this.headers.set(t,r)}<span class="fstat-no" title="function not covered" >f</span>orEach(t,r){for(let[n,i]of this.headers)t.call(r,i,n,this)}}</span>;var vd=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,Ua=L("prisma:client:dataproxyEngine");<span class="fstat-no" title="function not covered" >async function Td(e,t){let r=Ba["@prisma/engines-version"],n=t.clientVersion??"unknown";if(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&amp;&amp;vd.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){if(e.startsWith("localhost")||e.startsWith("127.0.0.1"))return"0.0.0";let[s]=r.split("-")??[],[a,l,u]=s.split("."),c=Rd(`&lt;=${a}.${l}.${u}`),p=await ct(c,{clientVersion:n});if(!p.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"&lt;empty body&gt;"}`);let d=await p.text();Ua("length of body fetched from unpkg.com",d.length);let f;try{f=JSON.parse(d)}catch(g){throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),g}return f.version}throw new lt("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}<span class="fstat-no" title="function not covered" >a</span>sync function Ga(e,t){let r=await Td(e,t);return Ua("version",r),r}<span class="fstat-no" title="function not covered" >f</span>unction Rd(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}v</span>ar Qa=3,Yi=L("prisma:client:dataproxyEngine"),Zi=class{<span class="fstat-no" title="function not covered" >constructor({apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}<span class="fstat-no" title="function not covered" >b</span>uild({traceparent:t,interactiveTransaction:r}={}){let n={Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};this.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=t??this.tracingHelper.getTraceParent()),r&amp;&amp;(n["X-transaction-id"]=r.id);let i=this.buildCaptureSettings();return i.length&gt;0&amp;&amp;(n["X-capture-telemetry"]=i.join(", ")),n}<span class="fstat-no" title="function not covered" >b</span>uildCaptureSettings(){let t=[];return this.tracingHelper.isEnabled()&amp;&amp;t.push("tracing"),this.logLevel&amp;&amp;t.push(this.logLevel),this.logQueries&amp;&amp;t.push("query"),t}}</span>,Sr=class{<span class="fstat-no" title="function not covered" >constructor(t){this.name="DataProxyEngine";ja(t),this.config=t,this.env={...t.env,...typeof process&lt;"u"?process.env:{}},this.inlineSchema=qa(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}<span class="fstat-no" title="function not covered" >a</span>piKey(){return this.headerBuilder.apiKey}<span class="fstat-no" title="function not covered" >v</span>ersion(){return this.engineHash}<span class="fstat-no" title="function not covered" >a</span>sync start(){this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(async()=&gt;{let[t,r]=this.extractHostAndApiKey();this.host=t,this.headerBuilder=new Zi({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Ga(t,this.config),Yi("host",this.host)})(),await this.startPromise}<span class="fstat-no" title="function not covered" >a</span>sync stop(){}<span class="fstat-no" title="function not covered" >p</span>ropagateResponseExtensions(t){t?.logs?.length&amp;&amp;t.logs.forEach(r=&gt;{switch(r.level){case"debug":case"error":case"trace":case"warn":case"info":break;case"query":{let n=typeof r.attributes.query=="string"?r.attributes.query:"";if(!this.tracingHelper.isEnabled()){let[i]=n.split("/* traceparent");n=i}this.logEmitter.emit("query",{query:n,timestamp:Va(r.timestamp),duration:Number(r.attributes.duration_ms),params:r.attributes.params,target:r.attributes.target})}}}),t?.traces?.length&amp;&amp;this.tracingHelper.createEngineSpan({span:!0,spans:t.traces})}<span class="fstat-no" title="function not covered" >o</span>nBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}<span class="fstat-no" title="function not covered" >a</span>sync url(t){return await this.start(),`https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}<span class="fstat-no" title="function not covered" >a</span>sync uploadSchema(){let t={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(t,async()=&gt;{let r=await ct(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});r.ok||Yi("schema response status",r.status);let n=await Rr(r,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}<span class="fstat-no" title="function not covered" >r</span>equest(t,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}<span class="fstat-no" title="function not covered" >a</span>sync requestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=wt(t,n),{batchResult:a,elapsed:l}=await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r});return a.map(u=&gt;"errors"in u&amp;&amp;u.errors.length&gt;0?st(u.errors[0],this.clientVersion,this.config.activeProvider):{data:u,elapsed:l})}<span class="fstat-no" title="function not covered" >r</span>equestInternal({body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=&gt;{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await ct(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,interactiveTransaction:i}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);a.ok||Yi("graphql response status",a.status),await this.handleError(await Rr(a,this.clientVersion));let l=await a.json(),u=l.extensions;if(u&amp;&amp;this.propagateResponseExtensions(u),l.errors)throw l.errors.length===1?st(l.errors[0],this.config.clientVersion,this.config.activeProvider):new B(l.errors,{clientVersion:this.config.clientVersion});return l}})}<span class="fstat-no" title="function not covered" >a</span>sync transaction(t,r,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[t]} transaction`,callback:async({logHttpCall:o})=&gt;{if(t==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await ct(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await Rr(l,this.clientVersion));let u=await l.json(),c=u.extensions;c&amp;&amp;this.propagateResponseExtensions(c);let p=u.id,d=u["data-proxy"].endpoint;return{id:p,payload:{endpoint:d}}}else{let s=`${n.payload.endpoint}/${t}`;o(s);let a=await ct(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});await this.handleError(await Rr(a,this.clientVersion));let u=(await a.json()).extensions;u&amp;&amp;this.propagateResponseExtensions(u);return}}})}<span class="fstat-no" title="function not covered" >e</span>xtractHostAndApiKey(){let t={clientVersion:this.clientVersion},r=Object.keys(this.inlineDatasources)[0],n=_t({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),i;try{i=new URL(n)}catch{throw new at(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}let{protocol:o,host:s,searchParams:a}=i;if(o!=="prisma:"&amp;&amp;o!=="prisma+postgres:")throw new at(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t);let l=a.get("api_key");if(l===null||l.length&lt;1)throw new at(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);return[s,l]}<span class="fstat-no" title="function not covered" >m</span>etrics(){throw new lt("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}<span class="fstat-no" title="function not covered" >a</span>sync withRetry(t){for(let r=0;;r++){let n=i=&gt;{this.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})};try{return await t.callback({logHttpCall:n})}catch(i){if(!(i instanceof se)||!i.isRetryable)throw i;if(r&gt;=Qa)throw i instanceof Ft?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${r+1}/${Qa} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await $a(r);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}<span class="fstat-no" title="function not covered" >a</span>sync handleError(t){if(t instanceof ut)throw await this.uploadSchema(),new Ft({clientVersion:this.clientVersion,cause:t});if(t)throw t}<span class="fstat-no" title="function not covered" >a</span>pplyPendingMigrations(){throw new Error("Method not implemented.")}}</span>;<span class="fstat-no" title="function not covered" >function Ja(e){if(e?.kind==="itx")return e.options.id}v</span>ar eo=k(require("os")),Wa=k(require("path"));var Xi=Symbol("PrismaLibraryEngineCache");function Cd(){let e=globalThis;return e[Xi]===void 0&amp;&amp;(e[Xi]={}),e[Xi]}function Sd(e){let t=Cd();if(t[e]!==void 0)<span class="branch-0 cbranch-no" title="branch not covered" >return t[e];l</span>et r=Wa.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"&amp;&amp;(i=eo.default.constants.dlopen.RTLD_LAZY|eo.default.constants.dlopen.RTLD_DEEPBIND),process.dlopen(n,r,i),t[e]=n.exports,n.exports}var Ha={async loadLibrary(e){let t=await zn(),r=await ka("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=&gt;Sd(r))}<span class="branch-0 cbranch-no" title="branch not covered" >catch(n){let i=li({e:n,platformInfo:t,id:r});throw new R(i,e.clientVersion)}}</span>};var to,Ka={<span class="fstat-no" title="function not covered" >async loadLibrary(e){let{clientVersion:t,adapter:r,engineWasm:n}=e;if(r===void 0)throw new R(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Tn().prettyName})`,t);if(n===void 0)throw new R("WASM engine was unexpectedly `undefined`",t);to===void 0&amp;&amp;(to=(async()=&gt;{let o=n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new R("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",t);let a={"./query_engine_bg.js":o},l=new WebAssembly.Instance(s,a);return o.__wbg_set_wasm(l.exports),o.QueryEngine})());let i=await to;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}}</span>;var Ad="P2036",Ae=L("prisma:client:libraryEngine");<span class="fstat-no" title="function not covered" >function Id(e){return e.item_type==="query"&amp;&amp;"query"in e}<span class="fstat-no" title="function not covered" >f</span>unction Od(e){return"level"in e?e.level==="error"&amp;&amp;e.message==="PANIC":!1}v</span>ar za=[...Qn,"native"],Ar=class{constructor(t,r){this.name="LibraryEngine";this.libraryLoader=r??Ha,t.engineWasm!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this.libraryLoader=r??Ka),</span>this.config=t,this.libraryStarted=!1,this.logQueries=t.logQueries??!1,this.logLevel=t.logLevel??"error",this.logEmitter=t.logEmitter,this.datamodel=t.inlineSchema,t.enableDebugLogs<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(this.logLevel="debug");</span>let n=Object.keys(t.overrideDatasources)[0],i=t.overrideDatasources[n]<span class="branch-0 cbranch-no" title="branch not covered" >?.url;</span>n!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;i!==void 0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;</span>&amp;(this.datasourceOverrides={[n]:i}),</span>this.libraryInstantiationPromise=this.instantiateLibrary()}<span class="fstat-no" title="function not covered" >async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}<span class="fstat-no" title="function not covered" >a</span>sync transaction(t,r,n){await this.start();let i=JSON.stringify(r),o;if(t==="start"){let a=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});o=await this.engine?.startTransaction(a,i)}else t==="commit"?o=await this.engine?.commitTransaction(n.id,i):t==="rollback"&amp;&amp;(o=await this.engine?.rollbackTransaction(n.id,i));let s=this.parseEngineResponse(o);if(kd(s)){let a=this.getExternalAdapterError(s);throw a?a.error:new V(s.message,{code:s.error_code,clientVersion:this.config.clientVersion,meta:s.meta})}return s}a</span>sync instantiateLibrary(){if(Ae("internalSetup"),this.libraryInstantiationPromise)<span class="branch-0 cbranch-no" title="branch not covered" >return this.libraryInstantiationPromise;G</span>n(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.loadEngine(),this.version()}async getCurrentBinaryTarget(){{if(this.binaryTarget)<span class="branch-0 cbranch-no" title="branch not covered" >return this.binaryTarget;l</span>et t=await nt();if(!za.includes(t))<span class="branch-0 cbranch-no" title="branch not covered" >throw new R(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(H(t))}. Possible binaryTargets: ${qe(za.join(", "))} or a path to the query engine library.</span>
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return t}}<span class="fstat-no" title="function not covered" >parseEngineResponse(t){if(!t)throw new B("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(t)}catch{throw new B("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}a</span>sync loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let t=new WeakRef(this),{adapter:r}=this.config;r<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Ae("Using driver adapter: %O",r),</span>this.engine=new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json"},n=&gt;{t.deref()?.logger(n)},r)}<span class="branch-0 cbranch-no" title="branch not covered" >catch(t){let r=t,n=this.parseInitError(r.message);throw typeof n=="string"?r:new R(n.message,this.config.clientVersion,n.error_code)}}</span>}<span class="fstat-no" title="function not covered" >logger(t){let r=this.parseEngineResponse(t);if(r){if("span"in r){this.config.tracingHelper.createEngineSpan(r);return}r.level=r?.level.toLowerCase()??"unknown",Id(r)?this.logEmitter.emit("query",{timestamp:new Date,query:r.query,params:r.params,duration:Number(r.duration_ms),target:r.module_path}):Od(r)?this.loggerRustPanic=new le(ro(this,`${r.message}: ${r.reason} in ${r.file}:${r.line}:${r.column}`),this.config.clientVersion):this.logEmitter.emit(r.level,{timestamp:new Date,message:r.message,target:r.module_path})}}<span class="fstat-no" title="function not covered" >p</span>arseInitError(t){try{return JSON.parse(t)}catch{}return t}<span class="fstat-no" title="function not covered" >p</span>arseRequestError(t){try{return JSON.parse(t)}catch{}return t}<span class="fstat-no" title="function not covered" >o</span>nBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}<span class="fstat-no" title="function not covered" >a</span>sync start(){if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return Ae(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let t=async()=&gt;{Ae("library starting");try{let r={traceparent:this.config.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(r)),this.libraryStarted=!0,Ae("library started")}catch(r){let n=this.parseInitError(r.message);throw typeof n=="string"?r:new R(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.config.tracingHelper.runInChildSpan("connect",t),this.libraryStartingPromise}<span class="fstat-no" title="function not covered" >a</span>sync stop(){if(await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Ae("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted)return;let t=async()=&gt;{await new Promise(n=&gt;setTimeout(n,5)),Ae("library stopping");let r={traceparent:this.config.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(r)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,Ae("library stopped")};return this.libraryStoppingPromise=this.config.tracingHelper.runInChildSpan("disconnect",t),this.libraryStoppingPromise}v</span>ersion(){return this.versionInfo=this.library?.version(),this.versionInfo?.version<span class="branch-0 cbranch-no" title="branch not covered" >??"unknown"}<span class="fstat-no" title="function not covered" ></span>debugPanic(t){return this.library?.debugPanic(t)}<span class="fstat-no" title="function not covered" >a</span>sync request(t,{traceparent:r,interactiveTransaction:n}){Ae(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:r}),o=JSON.stringify(t);try{await this.start(),this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let s=this.parseEngineResponse(await this.executingQueryPromise);if(s.errors)throw s.errors.length===1?this.buildQueryError(s.errors[0]):new B(JSON.stringify(s.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:s,elapsed:0}}catch(s){if(s instanceof R)throw s;if(s.code==="GenericFailure"&amp;&amp;s.message?.startsWith("PANIC:"))throw new le(ro(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new B(`${a.message}</span>
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}<span class="fstat-no" title="function not covered" >async requestBatch(t,{transaction:r,traceparent:n}){Ae("requestBatch");let i=wt(t,r);await this.start(),this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),Ja(r));let o=await this.executingQueryPromise,s=this.parseEngineResponse(o);if(s.errors)throw s.errors.length===1?this.buildQueryError(s.errors[0]):new B(JSON.stringify(s.errors),{clientVersion:this.config.clientVersion});let{batchResult:a,errors:l}=s;if(Array.isArray(a))return a.map(u=&gt;u.errors&amp;&amp;u.errors.length&gt;0?this.loggerRustPanic??this.buildQueryError(u.errors[0]):{data:u,elapsed:0});throw l&amp;&amp;l.length===1?new Error(l[0].error):new Error(JSON.stringify(s))}<span class="fstat-no" title="function not covered" >b</span>uildQueryError(t){if(t.user_facing_error.is_panic)return new le(ro(this,t.user_facing_error.message),this.config.clientVersion);let r=this.getExternalAdapterError(t.user_facing_error);return r?r.error:st(t,this.config.clientVersion,this.config.activeProvider)}<span class="fstat-no" title="function not covered" >g</span>etExternalAdapterError(t){if(t.error_code===Ad&amp;&amp;this.config.adapter){let r=t.meta?.id;zr(typeof r=="number","Malformed external JS error received from the engine");let n=this.config.adapter.errorRegistry.consumeError(r);return zr(n,"External error with reported id was not registered"),n}}<span class="fstat-no" title="function not covered" >a</span>sync metrics(t){await this.start();let r=await this.engine.metrics(JSON.stringify(t));return t.format==="prometheus"?r:this.parseEngineResponse(r)}}</span>;<span class="fstat-no" title="function not covered" >function kd(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.error_code!==void 0}<span class="fstat-no" title="function not covered" >f</span>unction ro(e,t){return Ma({binaryTarget:e.binaryTarget,title:t,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}f</span>unction Ya({copyEngine:e=!0},t){let r;try{r=_t({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...process.env},clientVersion:t.clientVersion})}<span class="branch-0 cbranch-no" title="branch not covered" >catch{}l</span>et n=!!(r?.startsWith("prisma://")||r?.startsWith("prisma+postgres://"));e&amp;&amp;n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Xt("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");</span>let i=Kt(t.generator),o=n||!e,s=!!t.adapter,a=i==="library",l=i==="binary";if(o<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;s|</span>|s<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!1)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{let u;throw e?r?.startsWith("prisma://")?u=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:u=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:u=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new J(u.join(`</span>
`),{clientVersion:t.clientVersion})}if(o)<span class="branch-0 cbranch-no" title="branch not covered" >return new Sr(t);i</span>f(a)return new Ar(t)<span class="branch-0 cbranch-no" title="branch not covered" >;throw new J("Invalid client engine type, please use `library` or `binary`",{clientVersion:t.clientVersion})}f</span>unction In({generator:e}){return e?.previewFeatures<span class="branch-0 cbranch-no" title="branch not covered" >??[]}<span class="fstat-no" title="function not covered" ></span>function Mt(e){return e.substring(0,1).toLowerCase()+e.substring(1)}v</span>ar nl=k(no());<span class="fstat-no" title="function not covered" >function tl(e,t,r){let n=rl(e),i=Dd(n),o=Fd(i);o?On(o,t,r):t.addErrorMessage(()=&gt;"Unknown error")}<span class="fstat-no" title="function not covered" >f</span>unction rl(e){return e.errors.flatMap(t=&gt;t.kind==="Union"?rl(t):[t])}<span class="fstat-no" title="function not covered" >f</span>unction Dd(e){let t=new Map,r=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){r.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=t.get(i);o?t.set(i,{...n,argument:{...n.argument,typeNames:_d(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}return r.push(...t.values()),r}<span class="fstat-no" title="function not covered" >f</span>unction _d(e,t){return[...new Set(e.concat(t))]}<span class="fstat-no" title="function not covered" >f</span>unction Fd(e){return wi(e,(t,r)=&gt;{let n=Xa(t),i=Xa(r);return n!==i?n-i:el(t)-el(r)})}<span class="fstat-no" title="function not covered" >f</span>unction Xa(e){let t=0;return Array.isArray(e.selectionPath)&amp;&amp;(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(t+=e.argumentPath.length),t}<span class="fstat-no" title="function not covered" >f</span>unction el(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}v</span>ar ue=class{<span class="fstat-no" title="function not covered" >constructor(t,r){this.name=t;this.value=r;this.isRequired=!1}<span class="fstat-no" title="function not covered" >m</span>akeRequired(){return this.isRequired=!0,this}<span class="fstat-no" title="function not covered" >w</span>rite(t){let{colors:{green:r}}=t.context;t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}}</span>;var Ir=class{<span class="fstat-no" title="function not covered" >constructor(){this.fields=[]}<span class="fstat-no" title="function not covered" >a</span>ddField(t,r){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}}),this}<span class="fstat-no" title="function not covered" >w</span>rite(t){let{colors:{green:r}}=t.context;t.writeLine(r("{")).withIndent(()=&gt;{t.writeJoined(St,this.fields).newLine()}).write(r("}")).addMarginSymbol(r("+"))}}</span>;<span class="fstat-no" title="function not covered" >function On(e,t,r){switch(e.kind){case"MutuallyExclusiveFields":Ld(e,t);break;case"IncludeOnScalar":Nd(e,t);break;case"EmptySelection":Md(e,t,r);break;case"UnknownSelectionField":Vd(e,t);break;case"InvalidSelectionValue":Bd(e,t);break;case"UnknownArgument":Ud(e,t);break;case"UnknownInputField":Gd(e,t);break;case"RequiredArgumentMissing":Qd(e,t);break;case"InvalidArgumentType":Jd(e,t);break;case"InvalidArgumentValue":Wd(e,t);break;case"ValueTooLarge":Hd(e,t);break;case"SomeFieldsMissing":Kd(e,t);break;case"TooManyFieldsGiven":zd(e,t);break;case"Union":tl(e,t,r);break;default:throw new Error("not implemented: "+e.kind)}}<span class="fstat-no" title="function not covered" >f</span>unction Ld(e,t){let r=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();r&amp;&amp;(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(n=&gt;`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}<span class="fstat-no" title="function not covered" >f</span>unction Nd(e,t){let[r,n]=Or(e.selectionPath),i=e.outputType,o=t.arguments.getDeepSelectionParent(r)?.value;if(o&amp;&amp;(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&amp;&amp;o.addSuggestion(new ue(s.name,"true"));t.addErrorMessage(s=&gt;{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${kr(s)}`:a+=".",a+=`</span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}<span class="fstat-no" title="function not covered" >function Md(e,t,r){let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){$d(e,t,i);return}if(n.hasField("select")){qd(e,t);return}}if(r?.[Mt(e.outputType.name)]){jd(e,t);return}t.addErrorMessage(()=&gt;`Unknown field at "${e.selectionPath.join(".")} selection"`)}<span class="fstat-no" title="function not covered" >f</span>unction $d(e,t,r){r.removeAllFields();for(let n of e.outputType.fields)r.addSuggestion(new ue(n.name,"false"));t.addErrorMessage(n=&gt;`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}<span class="fstat-no" title="function not covered" >f</span>unction qd(e,t){let r=e.outputType,n=t.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&amp;&amp;(n.removeAllFields(),sl(n,r)),t.addErrorMessage(o=&gt;i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${kr(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)}<span class="fstat-no" title="function not covered" >f</span>unction jd(e,t){let r=new Ir;for(let i of e.outputType.fields)i.isRelation||r.addField(i.name,"false");let n=new ue("omit",r).makeRequired();if(e.selectionPath.length===0)t.arguments.addSuggestion(n);else{let[i,o]=Or(e.selectionPath),a=t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new It;l.addSuggestion(n),a.value=l}}t.addErrorMessage(i=&gt;`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}<span class="fstat-no" title="function not covered" >f</span>unction Vd(e,t){let r=al(e.selectionPath,t);if(r.parentKind!=="unknown"){r.field.markAsError();let n=r.parent;switch(r.parentKind){case"select":sl(n,e.outputType);break;case"include":Yd(n,e.outputType);break;case"omit":Zd(n,e.outputType);break}}t.addErrorMessage(n=&gt;{let i=[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];return r.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(kr(n)),i.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction Bd(e,t){let r=al(e.selectionPath,t);r.parentKind!=="unknown"&amp;&amp;r.field.value.markAsError(),t.addErrorMessage(n=&gt;`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)}<span class="fstat-no" title="function not covered" >f</span>unction Ud(e,t){let r=e.argumentPath[0],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;(n.getField(r)?.markAsError(),Xd(n,e.arguments)),t.addErrorMessage(i=&gt;il(i,r,e.arguments.map(o=&gt;o.name)))}<span class="fstat-no" title="function not covered" >f</span>unction Gd(e,t){let[r,n]=Or(e.argumentPath),i=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(r)?.asObject();o&amp;&amp;ll(o,e.inputType)}t.addErrorMessage(o=&gt;il(o,n,e.inputType.fields.map(s=&gt;s.name)))}<span class="fstat-no" title="function not covered" >f</span>unction il(e,t,r){let n=[`Unknown argument \`${e.red(t)}\`.`],i=tm(t,r);return i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),r.length&gt;0&amp;&amp;n.push(kr(e)),n.join(" ")}<span class="fstat-no" title="function not covered" >f</span>unction Qd(e,t){let r;t.addErrorMessage(l=&gt;r?.value instanceof W&amp;&amp;r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=Or(e.argumentPath),s=new Ir,a=n.getDeepFieldValue(i)?.asObject();if(a)if(r=a.getField(o),r&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ue(o,s).makeRequired())}else{let l=e.inputTypes.map(ol).join(" | ");a.addSuggestion(new ue(o,l).makeRequired())}}<span class="fstat-no" title="function not covered" >f</span>unction ol(e){return e.kind==="list"?`${ol(e.elementType)}[]`:e.name}<span class="fstat-no" title="function not covered" >f</span>unction Jd(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=&gt;{let o=kn("or",e.argument.typeNames.map(s=&gt;i.green(s)));return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}<span class="fstat-no" title="function not covered" >f</span>unction Wd(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=&gt;{let o=[`Invalid value for argument \`${i.bold(r)}\``];if(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=kn("or",e.argument.typeNames.map(a=&gt;i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}<span class="fstat-no" title="function not covered" >f</span>unction Hd(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof W&amp;&amp;(i=s.text)}t.addErrorMessage(o=&gt;{let s=["Unable to fit value"];return i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction Kd(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&amp;&amp;ll(i,e.inputType)}t.addErrorMessage(i=&gt;{let o=[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${kn("or",e.constraints.requiredFields.map(s=&gt;`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(kr(i)),o.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction zd(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}t.addErrorMessage(o=&gt;{let s=[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${kn("and",i.map(a=&gt;o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}<span class="fstat-no" title="function not covered" >f</span>unction sl(e,t){for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ue(r.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Yd(e,t){for(let r of t.fields)r.isRelation&amp;&amp;!e.hasField(r.name)&amp;&amp;e.addSuggestion(new ue(r.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Zd(e,t){for(let r of t.fields)!e.hasField(r.name)&amp;&amp;!r.isRelation&amp;&amp;e.addSuggestion(new ue(r.name,"true"))}<span class="fstat-no" title="function not covered" >f</span>unction Xd(e,t){for(let r of t)e.hasField(r.name)||e.addSuggestion(new ue(r.name,r.typeNames.join(" | ")))}<span class="fstat-no" title="function not covered" >f</span>unction al(e,t){let[r,n]=Or(e),i=t.arguments.getDeepSubSelectionValue(r)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&amp;&amp;l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}<span class="fstat-no" title="function not covered" >f</span>unction ll(e,t){if(t.kind==="object")for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ue(r.name,r.typeNames.join(" | ")))}<span class="fstat-no" title="function not covered" >f</span>unction Or(e){let t=[...e],r=t.pop();if(!r)throw new Error("unexpected empty path");return[t,r]}<span class="fstat-no" title="function not covered" >f</span>unction kr({green:e,enabled:t}){return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}<span class="fstat-no" title="function not covered" >f</span>unction kn(e,t){if(t.length===1)return t[0];let r=[...t],n=r.pop();return`${r.join(", ")} ${e} ${n}`}v</span>ar em=3;<span class="fstat-no" title="function not covered" >function tm(e,t){let r=1/0,n;for(let i of t){let o=(0,nl.default)(e,i);o&gt;em||o&lt;r&amp;&amp;(r=o,n=i)}return n}<span class="fstat-no" title="function not covered" >f</span>unction Dn({args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=Ot(e);for(let p of t)On(p,a,s);let{message:l,args:u}=yn(a,r),c=Dt({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:u});throw new J(c,{clientVersion:o})}v</span>ar rm={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},ul="explicitly `undefined` values are not allowed";<span class="fstat-no" title="function not covered" >function cl({modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i,callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new io({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:rm[t],query:Dr(r,p)}}<span class="fstat-no" title="function not covered" >f</span>unction Dr({select:e,include:t,...r}={},n){let i;return n.isPreviewFeatureOn("omitApi")&amp;&amp;(i=r.omit,delete r.omit),{arguments:dl(r,n),selection:nm(e,t,i,n)}}<span class="fstat-no" title="function not covered" >f</span>unction nm(e,t,r,n){return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&amp;&amp;n.isPreviewFeatureOn("omitApi")&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),am(e,n)):im(n,t,r)}<span class="fstat-no" title="function not covered" >f</span>unction im(e,t,r){let n={};return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),t&amp;&amp;om(n,t,e),e.isPreviewFeatureOn("omitApi")&amp;&amp;sm(n,r,e),n}<span class="fstat-no" title="function not covered" >f</span>unction om(e,t,r){for(let[n,i]of Object.entries(t)){if(we(i))continue;let o=r.nestSelection(n);if(oo(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=r.findField(n);if(s&amp;&amp;s.kind!=="object"&amp;&amp;r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){e[n]=Dr(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=Dr(i,o)}}<span class="fstat-no" title="function not covered" >f</span>unction sm(e,t,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...t},o=wa(i,n);for(let[s,a]of Object.entries(o)){if(we(a))continue;oo(a,r.nestSelection(s));let l=r.findField(s);n?.[s]&amp;&amp;!l||(e[s]=!a)}}<span class="fstat-no" title="function not covered" >f</span>unction am(e,t){let r={},n=t.getComputedFields(),i=Ea(e,n);for(let[o,s]of Object.entries(i)){if(we(s))continue;let a=t.nestSelection(o);oo(s,a);let l=t.findField(o);if(!(n?.[o]&amp;&amp;!l)){if(s===!1||s===void 0||we(s)){r[o]=!1;continue}if(s===!0){l?.kind==="object"?r[o]=Dr({},a):r[o]=!0;continue}r[o]=Dr(s,a)}}return r}<span class="fstat-no" title="function not covered" >f</span>unction pl(e,t){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(Pt(e)){if(on(e))return{$type:"DateTime",value:e.toISOString()};t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Ct(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return lm(e,t);if(ArrayBuffer.isView(e))return{$type:"Bytes",value:Buffer.from(e).toString("base64")};if(um(e))return e.values;if(Rt(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Ne){if(e!==en.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(cm(e))return e.toJSON();if(typeof e=="object")return dl(e,t);t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}<span class="fstat-no" title="function not covered" >f</span>unction dl(e,t){if(e.$type)return{$type:"Raw",value:e};let r={};for(let n in e){let i=e[n],o=t.nestArgument(n);we(i)||(i!==void 0?r[n]=pl(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:ul}))}return r}<span class="fstat-no" title="function not covered" >f</span>unction lm(e,t){let r=[];for(let n=0;n&lt;e.length;n++){let i=t.nestArgument(String(n)),o=e[n];if(o===void 0||we(o)){let s=o===void 0?"undefined":"Prisma.skip";t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}r.push(pl(o,i))}return r}<span class="fstat-no" title="function not covered" >f</span>unction um(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}<span class="fstat-no" title="function not covered" >f</span>unction cm(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}<span class="fstat-no" title="function not covered" >f</span>unction oo(e,t){e===void 0&amp;&amp;t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:ul})}v</span>ar io=class e{<span class="fstat-no" title="function not covered" >constructor(t){this.params=t;this.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}<span class="fstat-no" title="function not covered" >t</span>hrowValidationError(t){Dn({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" >g</span>etSelectionPath(){return this.params.selectionPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentPath(){return this.params.argumentPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" >g</span>etOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(t=&gt;({name:t.name,typeName:"boolean",isRelation:t.kind==="object"}))}}<span class="fstat-no" title="function not covered" >i</span>sRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" >i</span>sPreviewFeatureOn(t){return this.params.previewFeatures.includes(t)}<span class="fstat-no" title="function not covered" >g</span>etComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" >f</span>indField(t){return this.modelOrType?.fields.find(r=&gt;r.name===t)}<span class="fstat-no" title="function not covered" >n</span>estSelection(t){let r=this.findField(t),n=r?.kind==="object"?r.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}<span class="fstat-no" title="function not covered" >g</span>etGlobalOmit(){return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[Mt(this.params.modelName)]??{}:{}}<span class="fstat-no" title="function not covered" >s</span>houldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:Fe(this.params.action,"Unknown action")}}<span class="fstat-no" title="function not covered" >n</span>estArgument(t){return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}}</span>;var ml=<span class="fstat-no" title="function not covered" >e=&gt;({command:e});</span>var fl=<span class="fstat-no" title="function not covered" >e=&gt;e.strings.reduce((t,r,n)=&gt;`${t}@P${n}${r}`);<span class="fstat-no" title="function not covered" ></span>function $t(e){try{return gl(e,"fast")}catch{return gl(e,"slow")}}<span class="fstat-no" title="function not covered" >f</span>unction gl(e,t){return JSON.stringify(e.map(r=&gt;yl(r,t)))}<span class="fstat-no" title="function not covered" >f</span>unction yl(e,t){return Array.isArray(e)?e.map(r=&gt;yl(r,t)):typeof e=="bigint"?{prisma__type:"bigint",prisma__value:e.toString()}:Pt(e)?{prisma__type:"date",prisma__value:e.toJSON()}:Re.isDecimal(e)?{prisma__type:"decimal",prisma__value:e.toJSON()}:Buffer.isBuffer(e)?{prisma__type:"bytes",prisma__value:e.toString("base64")}:pm(e)||ArrayBuffer.isView(e)?{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")}:typeof e=="object"&amp;&amp;t==="slow"?bl(e):e}<span class="fstat-no" title="function not covered" >f</span>unction pm(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}<span class="fstat-no" title="function not covered" >f</span>unction bl(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(hl);let t={};for(let r of Object.keys(e))t[r]=hl(e[r]);return t}<span class="fstat-no" title="function not covered" >f</span>unction hl(e){return typeof e=="bigint"?e.toString():bl(e)}v</span>ar dm=["$connect","$disconnect","$on","$transaction","$use","$extends"],El=dm;var mm=/^(\s*alter\s)/i,wl=L("prisma:client");<span class="fstat-no" title="function not covered" >function so(e,t,r,n){if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;r.length&gt;0&amp;&amp;mm.exec(t))throw new Error(`Running ALTER using ${n} is not supported</span>
<span class="cstat-no" title="statement not covered" >Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >Example:</span>
<span class="cstat-no" title="statement not covered" >  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >More Information: https://pris.ly/d/execute-raw</span>
`)}var ao=<span class="fstat-no" title="function not covered" >({clientMethod:e,activeProvider:t})=&gt;r=&gt;{let n="",i;if(r instanceof sr)n=r.sql,i={values:$t(r.values),__prismaRawParameters__:!0};else if(Array.isArray(r)){let[o,...s]=r;n=o,i={values:$t(s||[]),__prismaRawParameters__:!0}}else switch(t){case"sqlite":case"mysql":{n=r.sql,i={values:$t(r.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=r.text,i={values:$t(r.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=fl(r),i={values:$t(r.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${t} provider does not support ${e}`)}return i?.values?wl(`prisma.${e}(${n}, ${i.values})`):wl(`prisma.${e}(${n})`),{query:n,parameters:i}},</span>xl={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},<span class="fstat-no" title="function not covered" ></span>middlewareArgsToRequestArgs(e){let[t,...r]=e;return new ie(t,r)}}</span>,Pl={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e){return[e]},<span class="fstat-no" title="function not covered" ></span>middlewareArgsToRequestArgs(e){return e[0]}}</span>;function lo(e){return function(r){let n,i=(o=e)=&gt;{try{return o===void 0||o?.kind==="itx"?n??=vl(r(o)):vl(r(o))}catch(s){return Promise.reject(s)}};return{then(o,s){return i().then(o,s)},catch(o){return i().catch(o)},finally(o){return i().finally(o)},requestTransaction(o){let s=i(o);return s.requestTransaction?s.requestTransaction(o):s},[Symbol.toStringTag]:"PrismaPromise"}}}<span class="fstat-no" title="function not covered" >function vl(e){return typeof e.then=="function"?e:Promise.resolve(e)}v</span>ar Tl={<span class="fstat-no" title="function not covered" >isEnabled(){return!1},<span class="fstat-no" title="function not covered" ></span>getTraceParent(){return"00-10-10-00"},<span class="fstat-no" title="function not covered" ></span>async createEngineSpan(){},<span class="fstat-no" title="function not covered" ></span>getActiveContext(){},</span>runInChildSpan(e,t){return t()}},uo=class{<span class="fstat-no" title="function not covered" >isEnabled(){return this.getGlobalTracingHelper().isEnabled()}<span class="fstat-no" title="function not covered" >g</span>etTraceParent(t){return this.getGlobalTracingHelper().getTraceParent(t)}<span class="fstat-no" title="function not covered" >c</span>reateEngineSpan(t){return this.getGlobalTracingHelper().createEngineSpan(t)}<span class="fstat-no" title="function not covered" >g</span>etActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}<span class="fstat-no" title="function not covered" >r</span>unInChildSpan(t,r){return this.getGlobalTracingHelper().runInChildSpan(t,r)}<span class="fstat-no" title="function not covered" >g</span>etGlobalTracingHelper(){return globalThis.PRISMA_INSTRUMENTATION?.helper??Tl}}</span>;function Rl(e){return e.includes("tracing")<span class="branch-0 cbranch-no" title="branch not covered" >?new uo:</span>Tl}<span class="fstat-no" title="function not covered" >function Cl(e,t=()=&gt;{}){let r,n=new Promise(i=&gt;r=i);return{then(i){return--e===0&amp;&amp;r(t()),i?.(n)}}}<span class="fstat-no" title="function not covered" >f</span>unction Sl(e){return typeof e=="string"?e:e.reduce((t,r)=&gt;{let n=typeof r=="string"?r:r.level;return n==="query"?t:t&amp;&amp;(r==="info"||t==="info")?"info":n},void 0)}v</span>ar _n=class{constructor(){this._middlewares=[]}<span class="fstat-no" title="function not covered" >use(t){this._middlewares.push(t)}<span class="fstat-no" title="function not covered" >g</span>et(t){return this._middlewares[t]}<span class="fstat-no" title="function not covered" >h</span>as(t){return!!this._middlewares[t]}<span class="fstat-no" title="function not covered" >l</span>ength(){return this._middlewares.length}}</span>;var Ol=k(yi());<span class="fstat-no" title="function not covered" >function Fn(e){return typeof e.batchRequestIdx=="number"}<span class="fstat-no" title="function not covered" >f</span>unction Ln(e){return e===null?e:Array.isArray(e)?e.map(Ln):typeof e=="object"?fm(e)?gm(e):yt(e,Ln):e}<span class="fstat-no" title="function not covered" >f</span>unction fm(e){return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}<span class="fstat-no" title="function not covered" >f</span>unction gm({$type:e,value:t}){switch(e){case"BigInt":return BigInt(t);case"Bytes":return Buffer.from(t,"base64");case"DateTime":return new Date(t);case"Decimal":return new Re(t);case"Json":return JSON.parse(t);default:Fe(t,"Unknown tagged value")}}<span class="fstat-no" title="function not covered" >f</span>unction Al(e){if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")return;let t=[];return e.modelName&amp;&amp;t.push(e.modelName),e.query.arguments&amp;&amp;t.push(co(e.query.arguments)),t.push(co(e.query.selection)),t.join("")}<span class="fstat-no" title="function not covered" >f</span>unction co(e){return`(${Object.keys(e).sort().map(r=&gt;{let n=e[r];return typeof n=="object"&amp;&amp;n!==null?`(${r} ${co(n)})`:r}).join(" ")})`}v</span>ar hm={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateOne:!0,upsertOne:!0};<span class="fstat-no" title="function not covered" >function po(e){return hm[e]}v</span>ar Nn=class{constructor(t){this.options=t;this.tickActive=!1;this.batches={}}<span class="fstat-no" title="function not covered" >request(t){let r=this.options.batchBy(t);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=&gt;{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=&gt;{this.batches[r].push({request:t,resolve:n,reject:i})})):this.options.singleLoader(t)}<span class="fstat-no" title="function not covered" >d</span>ispatchBatches(){for(let t in this.batches){let r=this.batches[t];delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(n=&gt;{n instanceof Error?r[0].reject(n):r[0].resolve(n)}).catch(n=&gt;{r[0].reject(n)}):(r.sort((n,i)=&gt;this.options.batchOrder(n.request,i.request)),this.options.batchLoader(r.map(n=&gt;n.request)).then(n=&gt;{if(n instanceof Error)for(let i=0;i&lt;r.length;i++)r[i].reject(n);else for(let i=0;i&lt;r.length;i++){let o=n[i];o instanceof Error?r[i].reject(o):r[i].resolve(o)}}).catch(n=&gt;{for(let i=0;i&lt;r.length;i++)r[i].reject(n)}))}}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"DataLoader"}}</span>;<span class="fstat-no" title="function not covered" >function pt(e,t){if(t===null)return t;switch(e){case"bigint":return BigInt(t);case"bytes":return Buffer.from(t,"base64");case"decimal":return new Re(t);case"datetime":case"date":return new Date(t);case"time":return new Date(`1970-01-01T${t}Z`);case"bigint-array":return t.map(r=&gt;pt("bigint",r));case"bytes-array":return t.map(r=&gt;pt("bytes",r));case"decimal-array":return t.map(r=&gt;pt("decimal",r));case"datetime-array":return t.map(r=&gt;pt("datetime",r));case"date-array":return t.map(r=&gt;pt("date",r));case"time-array":return t.map(r=&gt;pt("time",r));default:return t}}<span class="fstat-no" title="function not covered" >f</span>unction Il(e){let t=[],r=ym(e);for(let n=0;n&lt;e.rows.length;n++){let i=e.rows[n],o={...r};for(let s=0;s&lt;i.length;s++)o[e.columns[s]]=pt(e.types[s],i[s]);t.push(o)}return t}<span class="fstat-no" title="function not covered" >f</span>unction ym(e){let t={};for(let r=0;r&lt;e.columns.length;r++)t[e.columns[r]]=null;return t}v</span>ar bm=L("prisma:client:request_handler"),Mn=class{constructor(t,r){this.logEmitter=r,this.client=t,this.dataloader=new Nn({batchLoader:fa(async({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=&gt;p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=&gt;po(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Em(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=&gt;{if(p instanceof Error)return p;try{return this.mapQueryEngineResult(n[d],p)}catch(f){return f}})}),singleLoader:<span class="fstat-no" title="function not covered" >async n=&gt;{let i=n.transaction?.kind==="itx"?kl(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:po(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},</span>batchBy:<span class="fstat-no" title="function not covered" >n=&gt;n.transaction?.id?`transaction-${n.transaction.id}`:Al(n.protocolQuery),<span class="fstat-no" title="function not covered" ></span>batchOrder(n,i){return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}}</span>)}<span class="fstat-no" title="function not covered" >async request(t){try{return await this.dataloader.request(t)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=t;this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}}<span class="fstat-no" title="function not covered" >m</span>apQueryEngineResult({dataPath:t,unpacker:r},n){let i=n?.data,o=n?.elapsed,s=this.unpack(i,t,r);return process.env.PRISMA_CLIENT_GET_TIME?{data:s,elapsed:o}:s}<span class="fstat-no" title="function not covered" >h</span>andleAndLogRequestError(t){try{this.handleRequestError(t)}catch(r){throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}}<span class="fstat-no" title="function not covered" >h</span>andleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(bm(t),wm(t,i)||t instanceof Le)throw t;if(t instanceof V&amp;&amp;xm(t)){let u=Dl(t.meta);Dn({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}let l=t.message;if(n&amp;&amp;(l=Dt({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let u=s?{modelName:s,...t.meta}:t.meta;throw new V(l,{code:t.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:t.batchRequestIdx})}else{if(t.isPanic)throw new le(l,this.client._clientVersion);if(t instanceof B)throw new B(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});if(t instanceof R)throw new R(l,this.client._clientVersion);if(t instanceof le)throw new le(l,this.client._clientVersion)}throw t.clientVersion=this.client._clientVersion,t}<span class="fstat-no" title="function not covered" >s</span>anitizeMessage(t){return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,Ol.default)(t):t}<span class="fstat-no" title="function not covered" >u</span>npack(t,r,n){if(!t||(t.data&amp;&amp;(t=t.data),!t))return t;let i=Object.keys(t)[0],o=Object.values(t)[0],s=r.filter(u=&gt;u!=="select"&amp;&amp;u!=="include"),a=$i(o,s),l=i==="queryRaw"?Il(a):Ln(a);return n?n(l):l}<span class="fstat-no" title="function not covered" >g</span>et[Symbol.toStringTag](){return"RequestHandler"}}</span>;<span class="fstat-no" title="function not covered" >function Em(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:kl(e)};Fe(e,"Unknown transaction kind")}}<span class="fstat-no" title="function not covered" >f</span>unction kl(e){return{id:e.id,payload:e.payload}}<span class="fstat-no" title="function not covered" >f</span>unction wm(e,t){return Fn(e)&amp;&amp;t?.kind==="batch"&amp;&amp;e.batchRequestIdx!==t.index}<span class="fstat-no" title="function not covered" >f</span>unction xm(e){return e.code==="P2009"||e.code==="P2012"}<span class="fstat-no" title="function not covered" >f</span>unction Dl(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(Dl)};if(Array.isArray(e.selectionPath)){let[,...t]=e.selectionPath;return{...e,selectionPath:t}}return e}v</span>ar _l="5.21.1";var Fl=_l;var ql=k(no());var F=class extends Error{<span class="fstat-no" title="function not covered" >constructor(t){super(t+`</span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}}</span>;w(F,"PrismaClientConstructorValidationError");var Ll=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],Nl=["pretty","colorless","minimal"],Ml=["info","query","warn","error"],vm={datasources:<span class="fstat-no" title="function not covered" >(e,{datasourceNames:t})=&gt;{if(e){if(typeof e!="object"||Array.isArray(e))throw new F(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[r,n]of Object.entries(e)){if(!t.includes(r)){let i=qt(r,t)||` Available datasources: ${t.join(", ")}`;throw new F(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new F(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span>
<span class="cstat-no" title="statement not covered" >It should have this form: { url: "CONNECTION_STRING" }`);if(n&amp;&amp;typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new F(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span>
<span class="cstat-no" title="statement not covered" >It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new F(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e,t)=&gt;{if(e===null)return;if(e===void 0)throw new F('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!In(t).includes("driverAdapters"))throw new F('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Kt()==="binary")throw new F('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},</span>datasourceUrl:<span class="fstat-no" title="function not covered" >e=&gt;{if(typeof e&lt;"u"&amp;&amp;typeof e!="string")throw new F(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=&gt;{if(e){if(typeof e!="string")throw new F(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!Nl.includes(e)){let t=qt(e,Nl);throw new F(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}}},</span>log:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;if(!Array.isArray(e))throw new F(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function t(r){if(typeof r=="string"&amp;&amp;!Ml.includes(r)){let n=qt(r,Ml);throw new F(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}}for(let r of e){t(r);let n={level:t,emit:i=&gt;{let o=["stdout","event"];if(!o.includes(i)){let s=qt(i,o);throw new F(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(r&amp;&amp;typeof r=="object")for(let[i,o]of Object.entries(r))if(n[i])n[i](o);else throw new F(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},</span>transactionOptions:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;let t=e.maxWait;if(t!=null&amp;&amp;t&lt;=0)throw new F(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let r=e.timeout;if(r!=null&amp;&amp;r&lt;=0)throw new F(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},</span>omit:<span class="fstat-no" title="function not covered" >(e,t)=&gt;{if(typeof e!="object")throw new F('"omit" option is expected to be an object.');if(e===null)throw new F('"omit" option can not be `null`');let r=[];for(let[n,i]of Object.entries(e)){let o=Rm(n,t.runtimeDataModel);if(!o){r.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=&gt;u.name===s);if(!l){r.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&amp;&amp;r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(r.length&gt;0)throw new F(Cm(e,r))},</span>__internal:<span class="fstat-no" title="function not covered" >e=&gt;{if(!e)return;let t=["debug","engine","configOverride"];if(typeof e!="object")throw new F(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[r]of Object.entries(e))if(!t.includes(r)){let n=qt(r,t);throw new F(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}}}</span>;<span class="fstat-no" title="function not covered" >function jl(e,t){for(let[r,n]of Object.entries(e)){if(!Ll.includes(r)){let i=qt(r,Ll);throw new F(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}vm[r](n,t)}if(e.datasourceUrl&amp;&amp;e.datasources)throw new F('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}<span class="fstat-no" title="function not covered" >f</span>unction qt(e,t){if(t.length===0||typeof e!="string")return"";let r=Tm(e,t);return r?` Did you mean "${r}"?`:""}<span class="fstat-no" title="function not covered" >f</span>unction Tm(e,t){if(t.length===0)return null;let r=t.map(i=&gt;({value:i,distance:(0,ql.default)(e,i)}));r.sort((i,o)=&gt;i.distance&lt;o.distance?-1:1);let n=r[0];return n.distance&lt;3?n.value:null}<span class="fstat-no" title="function not covered" >f</span>unction Rm(e,t){return $l(t.models,e)??$l(t.types,e)}<span class="fstat-no" title="function not covered" >f</span>unction $l(e,t){let r=Object.keys(e).find(n=&gt;Mt(n)===t);if(r)return e[r]}<span class="fstat-no" title="function not covered" >f</span>unction Cm(e,t){let r=Ot(e);for(let o of t)switch(o.kind){case"UnknownModel":r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(()=&gt;`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=&gt;`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=&gt;'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=&gt;"Omit field option value must be a boolean.");break}let{message:n,args:i}=yn(r,"colorless");return`Error validating "omit" option:</span>
<span class="cstat-no" title="statement not covered" ></span>
<span class="cstat-no" title="statement not covered" >${i}</span>
<span class="cstat-no" title="statement not covered" ></span>
${n}`}<span class="fstat-no" title="function not covered" >function Vl(e){return e.length===0?Promise.resolve([]):new Promise((t,r)=&gt;{let n=new Array(e.length),i=null,o=!1,s=0,a=()=&gt;{o||(s++,s===e.length&amp;&amp;(o=!0,i?r(i):t(n)))},l=u=&gt;{o||(o=!0,r(u))};for(let u=0;u&lt;e.length;u++)e[u].then(c=&gt;{n[u]=c,a()},c=&gt;{if(!Fn(c)){l(c);return}c.batchRequestIdx===u?l(c):(i||(i=c),a())})})}v</span>ar tt=L("prisma:client");typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);var Sm={requestArgsToMiddlewareArgs:<span class="fstat-no" title="function not covered" >e=&gt;e,</span>middlewareArgsToRequestArgs:<span class="fstat-no" title="function not covered" >e=&gt;e}</span>,Am=Symbol.for("prisma.client.transaction.id"),Im={id:0,<span class="fstat-no" title="function not covered" >nextId(){return++this.id}}</span>;function Wl(e){class t{constructor(n){this._originalClient=this;this._middlewares=new _n;this._createPrismaPromise=lo();this.$extends=sa;e=n<span class="branch-0 cbranch-no" title="branch not covered" >?.__internal?.configOverride?.(e)?</span>?e,va(e),n<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;jl(n,e);</span>let i=new Ql.EventEmitter().on("error",()=&gt;{});this._extensions=vn.empty(),this._previewFeatures=In(e),this._clientVersion=e.clientVersion<span class="branch-0 cbranch-no" title="branch not covered" >??Fl,</span>this._activeProvider=e.activeProvider,this._globalOmit=n<span class="branch-0 cbranch-no" title="branch not covered" >?.omit,</span>this._tracingHelper=Rl(this._previewFeatures);let o={rootEnvPath:e.relativeEnvPaths.rootEnvPath<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;_r.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),</span>schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;_r.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n<span class="branch-0 cbranch-no" title="branch not covered" >?.adapter)<span class="branch-0 cbranch-no" title="branch not covered" ></span>{s=Ci(n.adapter);let l=e.activeProvider==="postgresql"?"postgres":e.activeProvider;if(s.provider!==l)throw new R(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new R("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}l</span>et a=!s&amp;&amp;Ht(o,{conflictCheck:"none"})<span class="branch-0 cbranch-no" title="branch not covered" >||e.injectableEdgeEnv?.();</span>try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;L.enable("prisma:client");</span>let p=_r.default.resolve(e.dirname,e.relativePath);Jl.default.existsSync(p)<span class="branch-0 cbranch-no" title="branch not covered" >||(p=e.dirname),</span>tt("dirname",e.dirname),tt("relativePath",e.relativePath),tt("cwd",p);let d=u.engine||{};if(l.errorFormat<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat=l.errorFormat:</span>process.env.NODE_ENV==="production"<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat="minimal":</span>process.env.NO_COLOR<span class="branch-0 cbranch-no" title="branch not covered" >?this._errorFormat="colorless":</span>this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,datamodelPath:_r.default.join(e.dirname,e.filename??"schema.prisma"),prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;Sl(l.log),</span>logQueries:l.log<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;!!(typeof l.log=="string"?l.log==="query":l.log.find(f=&gt;typeof f=="string"?f==="query":f.level==="query")),</span>env:a?.parsed<span class="branch-0 cbranch-no" title="branch not covered" >??{},</span>flags:[],engineWasm:e.engineWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Ta(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.maxWait?</span>?2e3,timeout:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.timeout?</span>?5e3,isolationLevel:l.transactionOptions<span class="branch-0 cbranch-no" title="branch not covered" >?.isolationLevel}</span>,logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:_t,getBatchRequestPayload:wt,prismaGraphQLToJSError:st,PrismaClientUnknownRequestError:B,PrismaClientInitializationError:R,PrismaClientKnownRequestError:V,debug:L("prisma:client:accelerateEngine"),engineVersion:Ul.version,clientVersion:e.clientVersion}},tt("clientVersion",e.clientVersion),this._engine=Ya(e,this._engineConfig),this._requestHandler=new Mn(this,i),l.log)<span class="branch-0 cbranch-no" title="branch not covered" >for(let f of l.log){let g=typeof f=="string"?f:f.emit==="stdout"?f.level:null;g&amp;&amp;this.$on(g,h=&gt;{Zt.log(`${Zt.tags[g]??""}`,h.message||h.query)})}t</span>his._metrics=new bt(this._engine)}<span class="branch-0 cbranch-no" title="branch not covered" >catch(l){throw l.clientVersion=this._clientVersion,l}r</span>eturn this._appliedParent=dr(this)}<span class="fstat-no" title="function not covered" >get[Symbol.toStringTag](){return"PrismaClient"}<span class="fstat-no" title="function not covered" >$</span>use(n){this._middlewares.use(n)}<span class="fstat-no" title="function not covered" >$</span>on(n,i){n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i)}<span class="fstat-no" title="function not covered" >$</span>connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}<span class="fstat-no" title="function not covered" >a</span>sync $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Ro()}}<span class="fstat-no" title="function not covered" >$</span>executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:ao({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" >$</span>executeRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=Bl(n,i);return so(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new J("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}<span class="fstat-no" title="function not covered" >$</span>executeRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;(so(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}<span class="fstat-no" title="function not covered" >$</span>runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new J(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=&gt;this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:ml,callsite:Ze(this._errorFormat),transaction:i}))}<span class="fstat-no" title="function not covered" >a</span>sync $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:ao({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" >$</span>queryRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...Bl(n,i));throw new J("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}<span class="fstat-no" title="function not covered" >$</span>queryRawTyped(n){return this._createPrismaPromise(i=&gt;{if(!this._hasPreviewFlag("typedSql"))throw new J("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}<span class="fstat-no" title="function not covered" >$</span>queryRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}<span class="fstat-no" title="function not covered" >_</span>transactionWithArray({promises:n,options:i}){let o=Im.nextId(),s=Cl(n.length),a=n.map((l,u)=&gt;{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??l});return Vl(a)}<span class="fstat-no" title="function not covered" >a</span>sync _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=&gt;{}),u}return l}<span class="fstat-no" title="function not covered" >_</span>createItxClient(n){return dr(ve(oa(this),[re("_appliedParent",()=&gt;this._appliedParent._createItxClient(n)),re("_createPrismaPromise",()=&gt;lo(n)),re(Am,()=&gt;n.id),Et(El)]))}<span class="fstat-no" title="function not covered" >$</span>transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=&gt;{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=&gt;this._transactionWithCallback({callback:n,options:i}):o=()=&gt;this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}<span class="fstat-no" title="function not covered" >_</span>request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Sm,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async u=&gt;{let c=this._middlewares.get(++a);if(c)return this._tracingHelper.runInChildSpan(s.middleware,O=&gt;c(u,T=&gt;(O?.end(),l(T))));let{runInTransaction:p,args:d,...f}=u,g={...n,...f};d&amp;&amp;(g.args=i.middlewareArgsToRequestArgs(d)),n.transaction!==void 0&amp;&amp;p===!1&amp;&amp;delete g.transaction;let h=await ma(this,g);return g.model?ua({result:h,modelName:g.model,args:g.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):h};return this._tracingHelper.runInChildSpan(s.operation,()=&gt;new Gl.AsyncResource("prisma-client-request").runInAsyncScope(()=&gt;l(o)))}<span class="fstat-no" title="function not covered" >a</span>sync _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?u(n):n;let g={name:"serialize"},h=this._tracingHelper.runInChildSpan(g,()=&gt;cl({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return L.enabled("prisma:client")&amp;&amp;(tt("Prisma Client call:"),tt(`prisma.${i}(${Vs(n)})`),tt("Generated request:"),tt(JSON.stringify(h,null,2)+`</span>
`)),c?.kind==="batch"&amp;&amp;await c.lock,this._requestHandler.request({protocolQuery:h,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(g){throw g.clientVersion=this._clientVersion,g}}<span class="fstat-no" title="function not covered" >get $metrics(){if(!this._hasPreviewFlag("metrics"))throw new J("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:this._clientVersion});return this._metrics}<span class="fstat-no" title="function not covered" >_</span>hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" >$</span>applyPendingMigrations(){return this._engine.applyPendingMigrations()}}</span>return t}<span class="fstat-no" title="function not covered" >function Bl(e,t){return Om(e)?[new ie(e,t),xl]:[e,Pl]}<span class="fstat-no" title="function not covered" >f</span>unction Om(e){return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}v</span>ar km=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Hl(e){return new Proxy(e,{<span class="fstat-no" title="function not covered" >get(t,r){if(r in t)return t[r];if(!km.has(r))throw new TypeError(`Invalid enum value: ${String(r)}`)}}</span>)}function Kl(e){Ht(e,{conflictCheck:"warn"})}0<span class="branch-0 cbranch-no" title="branch not covered" >&amp;&amp;(module.exports={Debug,Decimal,Extensions,MetricsClient,NotFoundError,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,defineDmmfProperty,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,skip,sqltag,warnEnvConflicts,warnOnce});</span>
/*! Bundled license information:
&nbsp;
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt;
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-11-14T17:37:50.697Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    